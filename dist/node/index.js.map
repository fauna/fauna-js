{
  "version": 3,
  "sources": ["../../src/index.ts", "../../src/client-configuration.ts", "../../src/errors.ts", "../../src/wire-protocol.ts", "../../src/http-client/fetch-client.ts", "../../src/http-client/index.ts", "../../src/regex.ts", "../../src/values/date-time.ts", "../../src/values/doc.ts", "../../src/values/set.ts", "../../src/tagged-type.ts", "../../src/client.ts", "../../src/query-builder.ts"],
  "sourcesContent": ["export { Client } from \"./client\";\nexport {\n  type ClientConfiguration,\n  type Endpoints,\n  endpoints,\n} from \"./client-configuration\";\nexport {\n  AuthenticationError,\n  AuthorizationError,\n  ClientError,\n  NetworkError,\n  ProtocolError,\n  QueryCheckError,\n  QueryRuntimeError,\n  QueryTimeoutError,\n  ServiceError,\n  ServiceInternalError,\n  ServiceTimeoutError,\n  ThrottlingError,\n} from \"./errors\";\nexport { type QueryBuilder, fql } from \"./query-builder\";\nexport {\n  type JSONObject,\n  type JSONValue,\n  type QueryFailure,\n  type QueryInfo,\n  type QueryInterpolation,\n  type QueryRequest,\n  type QueryRequestHeaders,\n  type QueryStats,\n  type QuerySuccess,\n  type Span,\n  type ValueFragment,\n} from \"./wire-protocol\";\nexport {\n  DateStub,\n  Document,\n  DocumentReference,\n  type DocumentT,\n  Module,\n  NamedDocument,\n  NamedDocumentReference,\n  Set,\n  TimeStub\n} from \"./values\"\n", "import { ValueFormat } from \"./wire-protocol\";\n\n/**\n * Configuration for a client.\n */\nexport interface ClientConfiguration {\n  /**\n   * The {@link URL} of Fauna to call. See {@link endpoints} for some default options.\n   */\n  endpoint: URL;\n  /**\n   * Determines the encoded format expected for the query `arguments` field, and\n   * the `data` field of a successful response.\n   * @remarks **Note, it is very unlikely you need to change this value from its default.**\n   * By default the driver transmits type information over the wire. Fauna also assumes type information is\n   * transmitted by default and thus leaving this value undefined will allow Fauna and the driver to send and\n   * receive type data.\n   *  Type information allows the driver and Fauna to distinguish between types such as int\" and \"long\" which do not\n   * have a standard way of distinguishing in JSON.\n   * Since Fauna assumes typed information is transmitted by default, clients can leave this value undefined to make\n   * full usage of Fauna's primitive types.\n   * You can also explicitly set this to \"tagged\" to get the typing data sent.\n   * Rare use cases can also deal with standard JSON by setting the value to \"simple\". Not that the types\n   * enocodable in standard JSON are a subset of the types encodable in the default \"tagged\" format.\n   * It is not recommended that users use the \"simple\" format as you will lose the typing of your data. e.g. a \"Date\"\n   * will no longer be recognized by the Fauna as a \"Date\", but will instead be treated as a string.\n   */\n  format?: ValueFormat;\n  /**\n   * The maximum number of connections to a make to Fauna.\n   */\n  max_conns: number;\n  /**\n   * A secret for your Fauna DB, used to authorize your queries.\n   * @see https://docs.fauna.com/fauna/current/security/keys\n   */\n  secret: string;\n  /**\n   * The timeout of each query, in milliseconds. This controls the maximum amount of\n   * time Fauna will execute your query before marking it failed.\n   * Default is undefined which let's Fauna determine the query timeout to apply. This\n   * is recommended for most queries.\n   */\n  query_timeout_ms?: number;\n  /**\n   * If true, unconditionally run the query as strictly serialized.\n   * This affects read-only transactions. Transactions which write\n   * will always be strictly serialized.\n   */\n  linearized?: boolean;\n  /**\n   * The max number of times to retry the query if contention is encountered.\n   */\n  max_contention_retries?: number;\n\n  /**\n   * Tags provided back via logging and telemetry.\n   */\n  query_tags?: { [key: string]: string };\n  /**\n   * A traceparent provided back via logging and telemetry.\n   * Must match format: https://www.w3.org/TR/trace-context/#traceparent-header\n   */\n  traceparent?: string;\n  /**\n   * Enable or disable typechecking of the query before evaluation. If no value\n   * is provided, the value of `typechecked` in the database configuration will\n   * be used.\n   */\n  typecheck?: boolean;\n}\n\n/**\n * An extensible interface for a set of Fauna endpoints.\n * @remarks Leverage the `[key: string]: URL;` field to extend to other endpoints.\n */\nexport interface Endpoints {\n  /** Fauna's cloud endpoint. */\n  cloud: URL;\n  /** Fauna's preview endpoint for testing new features - requires beta access. */\n  preview: URL;\n  /**\n   * An endpoint for interacting with local instance of Fauna (e.g. one running in a local docker container).\n   */\n  local: URL;\n  /**\n   * An alias for local.\n   */\n  localhost: URL;\n  /**\n   * Any other endpoint you want your client to support. For example, if you run all requests through a proxy\n   * configure it here. Most clients will not need to leverage this ability.\n   */\n  [key: string]: URL;\n}\n\n/**\n * A extensible set of endpoints for calling Fauna.\n * @remarks Most clients will will not need to extend this set.\n * @example\n * ## To Extend\n * ```typescript\n *   // add to the endpoints constant\n *   endpoints.myProxyEndpoint = new URL(\"https://my.proxy.url\");\n * ```\n */\nexport const endpoints: Endpoints = {\n  cloud: new URL(\"https://db.fauna.com\"),\n  preview: new URL(\"https://db.fauna-preview.com\"),\n  local: new URL(\"http://localhost:8443\"),\n  localhost: new URL(\"http://localhost:8443\"),\n};\n", "import type { ConstraintFailure, QueryFailure } from \"./wire-protocol\";\n\n/**\n * A common error base class for all other errors.\n */\nabstract class FaunaError extends Error {\n  constructor(...args: any[]) {\n    super(...args);\n  }\n}\n\n/**\n * An error representing a query failure returned by Fauna.\n */\nexport class ServiceError extends FaunaError {\n  /**\n   * The HTTP Status Code of the error.\n   */\n  readonly httpStatus: number;\n  /**\n   * A code for the error. Codes indicate the cause of the error.\n   * It is safe to write programmatic logic against the code. They are\n   * part of the API contract.\n   */\n  readonly code: string;\n  /**\n   * A summary of the error in a human readable form. Only present\n   * where message does not suffice.\n   */\n  readonly summary?: string;\n  /**\n   * A machine readable description of any constraint failures encountered by the query.\n   * Present only if this query encountered constraint failures.\n   */\n  readonly constraint_failures?: Array<ConstraintFailure>;\n\n  constructor(failure: QueryFailure, httpStatus: number) {\n    super(failure.error.message);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ServiceError);\n    }\n\n    this.name = \"ServiceError\";\n    this.code = failure.error.code;\n    this.httpStatus = httpStatus;\n    if (failure.summary) {\n      this.summary = failure.summary;\n    }\n    if (failure.error.constraint_failures !== undefined) {\n      this.constraint_failures = failure.error.constraint_failures;\n    }\n  }\n}\n\n/**\n * An error response that is the result of the query failing during execution.\n * QueryRuntimeError's occur when a bug in your query causes an invalid execution\n * to be requested.\n * The 'code' field will vary based on the specific error cause.\n */\nexport class QueryRuntimeError extends ServiceError {\n  constructor(failure: QueryFailure, httpStatus: 400) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, QueryRuntimeError);\n    }\n    this.name = \"QueryRuntimeError\";\n    // TODO trace, txn_ts, and stats not yet returned for QueryRuntimeError\n    // flip to check for those rather than a specific code.\n  }\n}\n\n/**\n * An error due to a \"compile-time\" check of the query\n * failing.\n */\nexport class QueryCheckError extends ServiceError {\n  constructor(failure: QueryFailure, httpStatus: 400) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, QueryCheckError);\n    }\n    this.name = \"QueryCheckError\";\n  }\n}\n\n/**\n * A failure due to the timeout being exceeded, but the timeout\n * was set lower than the query's expected processing time.\n * This response is distinguished from a ServiceTimeoutException\n * in that a QueryTimeoutError shows Fauna behaving in an expected\n * manner.\n */\nexport class QueryTimeoutError extends ServiceError {\n  /**\n   * Statistics regarding the query.\n   */\n  readonly stats?: { [key: string]: number };\n\n  constructor(failure: QueryFailure, httpStatus: 440) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, QueryTimeoutError);\n    }\n    this.name = \"QueryTimeoutError\";\n    this.stats = failure.stats;\n  }\n}\n\n/**\n * AuthenticationError indicates invalid credentials were\n * used.\n */\nexport class AuthenticationError extends ServiceError {\n  constructor(failure: QueryFailure, httpStatus: 401) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AuthenticationError);\n    }\n    this.name = \"AuthenticationError\";\n  }\n}\n\n/**\n * AuthorizationError indicates the credentials used do not have\n * permission to perform the requested action.\n */\nexport class AuthorizationError extends ServiceError {\n  constructor(failure: QueryFailure, httpStatus: 403) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AuthorizationError);\n    }\n    this.name = \"AuthorizationError\";\n  }\n}\n\n/**\n * ThrottlingError indicates some capacity limit was exceeded\n * and thus the request could not be served.\n */\nexport class ThrottlingError extends ServiceError {\n  constructor(failure: QueryFailure, httpStatus: 429) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ThrottlingError);\n    }\n    this.name = \"ThrottlingError\";\n  }\n}\n\n/**\n * ServiceInternalError indicates Fauna failed unexpectedly.\n */\nexport class ServiceInternalError extends ServiceError {\n  constructor(failure: QueryFailure, httpStatus: 500) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ServiceInternalError);\n    }\n    this.name = \"ServiceInternalError\";\n  }\n}\n\n/**\n * ServiceTimeoutError indicates Fauna was not available to servce\n * the request before the timeout was reached.\n */\nexport class ServiceTimeoutError extends ServiceError {\n  constructor(failure: QueryFailure, httpStatus: 503) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ServiceTimeoutError);\n    }\n    this.name = \"ServiceTimeoutError\";\n  }\n}\n\n/**\n * An error representing a failure internal to the client, itself.\n * This indicates Fauna was never called - the client failed internally\n * prior to sending the request.\n */\nexport class ClientError extends FaunaError {\n  constructor(message: string, options?: { cause: any }) {\n    super(message, options);\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ClientError);\n    }\n    this.name = \"ClientError\";\n  }\n}\n\n/**\n * An error representing a failure due to the network.\n * This indicates Fauna was never reached.\n */\nexport class NetworkError extends FaunaError {\n  constructor(message: string, options: { cause: any }) {\n    super(message, options);\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, NetworkError);\n    }\n    this.name = \"NetworkError\";\n  }\n}\n\n/**\n * An error representing a HTTP failure - but one not directly\n * emitted by Fauna.\n */\nexport class ProtocolError extends FaunaError {\n  /**\n   * The HTTP Status Code of the error.\n   */\n  readonly httpStatus: number;\n\n  constructor(error: { message: string; httpStatus: number }) {\n    super(error.message);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ProtocolError);\n    }\n\n    this.name = \"ProtocolError\";\n    this.httpStatus = error.httpStatus;\n  }\n}\n", "// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport { fql } from \"./query-builder\";\n\n/**\n * A request to make to Fauna.\n */\nexport interface QueryRequest extends QueryRequestHeaders {\n  /** The query */\n  query: string | QueryInterpolation;\n\n  /** Optional arguments. Variables in the query will be initialized to the\n   * value associated with an argument key.\n   */\n  arguments?: JSONObject;\n}\n\nexport interface QueryRequestHeaders {\n  /**\n   * Determines the encoded format expected for the query `arguments` field, and\n   * the `data` field of a successful response.\n   */\n  format?: ValueFormat;\n  /**\n   * If true, unconditionally run the query as strictly serialized.\n   * This affects read-only transactions. Transactions which write\n   * will always be strictly serialized.\n   * Overrides the optional setting for the client.\n   */\n  linearized?: boolean;\n  /**\n   * The timeout to use in this query in milliseconds.\n   * Overrides the timeout for the client.\n   */\n  query_timeout_ms?: number;\n  /**\n   * The max number of times to retry the query if contention is encountered.\n   * Overrides the optional setting for the client.\n   */\n  max_contention_retries?: number;\n\n  /**\n   * Tags provided back via logging and telemetry.\n   * Overrides the optional setting on the client.\n   */\n  query_tags?: Record<string, string>;\n  /**\n   * A traceparent provided back via logging and telemetry.\n   * Must match format: https://www.w3.org/TR/trace-context/#traceparent-header\n   * Overrides the optional setting for the client.\n   */\n  traceparent?: string;\n  /**\n   * Enable or disable typechecking of the query before evaluation. If no value\n   * is provided, the value of `typechecked` in the database configuration will\n   * be used.\n   */\n  typecheck?: boolean;\n}\n\n/**\n * tagged declares that type information is transmitted and received by the driver.\n * \"simple\" indicates it is not - pure JSON is used.\n * \"decorated\" will cause the service output to be shown in FQL syntax that could\n * hypothetically be used to query Fauna. This is intended to support CLI and\n * REPL like tools.\n * @example\n * ```typescript\n * // example of decorated output\n * { time: Time(\"2012-01-01T00:00:00Z\") }\n * ```\n */\nexport declare type ValueFormat = \"simple\" | \"tagged\" | \"decorated\";\n\nexport type QueryStats = {\n  /** The amount of Transactional Compute Ops consumed by the query. */\n  compute_ops: number;\n  /** The amount of Transactional Read Ops consumed by the query. */\n  read_ops: number;\n  /** The amount of Transactional Write Ops consumed by the query. */\n  write_ops: number;\n  /** The query run time in milliseconds. */\n  query_time_ms: number;\n  /** The amount of data read from storage, in bytes. */\n  storage_bytes_read: number;\n  /** The amount of data written to storage, in bytes. */\n  storage_bytes_write: number;\n  /** The number of times the transaction was retried due to write contention. */\n  contention_retries: number;\n};\n\nexport type QueryInfo = {\n  /** The last transaction timestamp of the query. A Unix epoch in microseconds. */\n  txn_ts?: number;\n  /** A readable summary of any warnings or logs emitted by the query. */\n  summary?: string;\n  /** The value of the x-query-tags header, if it was provided. */\n  query_tags?: Record<string, string>;\n  /** Stats on query performance and cost */\n  stats?: QueryStats;\n};\n\nexport type QuerySuccess<T> = QueryInfo & {\n  /**\n   * The result of the query. The data is any valid JSON value.\n   * @remarks\n   * data is type parameterized so that you can treat it as a\n   * certain type if you are using typescript.\n   */\n  data: T;\n  /** The query's inferred static result type. */\n  static_type?: string;\n};\n\n/**\n * A failed query response. Integrations which only want to report a human\n * readable version of the failure can simply print out the \"summary\" field.\n */\nexport type QueryFailure = QueryInfo & {\n  /**\n   * The result of the query resulting in\n   */\n  error: {\n    /** A predefined code which indicates the type of error. See XXX for a list of error codes. */\n    code: string;\n    /** A short, human readable description of the error */\n    message: string;\n    /**\n     * A machine readable description of any constraint failures encountered by the query.\n     * Present only if this query encountered constraint failures.\n     */\n    constraint_failures?: Array<ConstraintFailure>;\n  };\n};\n\n/**\n * A constraint failure triggered by a query.\n */\nexport type ConstraintFailure = {\n  /** Description of the constraint failure */\n  message: string;\n  /** Name of the failed constraint */\n  name?: string;\n  /** Path into the write input data to which the failure applies */\n  paths?: Array<number | string>;\n};\n\nexport type QueryResponse<T> = QuerySuccess<T> | QueryFailure;\n\nexport const isQuerySuccess = (res: any): res is QuerySuccess<any> =>\n  res instanceof Object && \"data\" in res;\n\nexport const isQueryFailure = (res: any): res is QueryFailure =>\n  res instanceof Object &&\n  \"error\" in res &&\n  res.error instanceof Object &&\n  \"code\" in res.error &&\n  \"message\" in res.error;\n\nexport const isQueryResponse = (res: any): res is QueryResponse<any> =>\n  isQueryResponse(res) || isQueryFailure(res);\n\n/**\n * A piece of an interpolated query. Interpolated queries can be safely composed\n * together without concern of query string injection.\n * @see {@link ValueFragment} and {@link FQLFragment} for additional\n * information\n */\nexport type QueryInterpolation = FQLFragment | ValueFragment;\n\n/**\n * A piece of an interpolated query that represents an actual value. Arguments\n * are passed to fauna using ValueFragments so that query string injection is\n * not possible.\n * @remarks A ValueFragment is created by this driver when a literal value or\n * object is provided as an argument to the {@link fql} tagged template\n * function.\n *\n * ValueFragments must always be encoded with tags, regardless of the \"x-format\"\n * request header sent.\n * @example\n * ```typescript\n *  const num = 17;\n *  const query = fql`${num} + 3)`;\n *  // produces\n *  { fql: [{ value: { \"@int\": \"17\" } }, \" + 3\"] }\n * ```\n */\nexport type ValueFragment = { value: JSONValue };\n\n/**\n * A piece of an interpolated query. Interpolated Queries can be safely composed\n * together without concern of query string injection.\n * @remarks A FQLFragment is created when calling the {@link fql} tagged\n * template function and can be passed as an argument to other QueryBuilders.\n * @example\n * ```typescript\n *  const num = 17;\n *  const query1 = fql`${num} + 3)`;\n *  const query2 = fql`5 + ${query1})`;\n *  // produces\n *  { fql: [\"5 + \", { fql: [{ value: { \"@int\": \"17\" } }, \" + 3\"] }] }\n * ```\n */\nexport type FQLFragment = { fql: (string | QueryInterpolation)[] };\n\n/**\n * A source span indicating a segment of FQL.\n */\nexport interface Span {\n  /**\n   * A string identifier of the FQL source. For example, if performing\n   * a raw query against the API this would be *query*.\n   */\n  src: string;\n  /**\n   * The span's starting index within the src, inclusive.\n   */\n  start: number;\n  /**\n   * The span's ending index within the src, inclusive.\n   */\n  end: number;\n  /**\n   * The name of the enclosing function, if applicable.\n   */\n  function: string;\n}\n\n/**\n * All objects returned from Fauna are valid JSON objects.\n */\nexport type JSONObject = {\n  [key: string]: JSONValue;\n};\n\n/**\n * All values returned from Fauna are valid JSON values.\n */\nexport type JSONValue =\n  | null\n  | string\n  | number\n  | bigint\n  | boolean\n  | JSONObject\n  | Array<JSONValue>;\n", "/** following reference needed to include types for experimental fetch API in Node */\n/// <reference lib=\"dom\" />\n\nimport { NetworkError } from \"../errors\";\nimport { HTTPClient, HTTPRequest, HTTPResponse } from \"./index\";\n\n/**\n * An implementation for {@link HTTPClient} that uses the native fetch API\n */\nexport class FetchClient implements HTTPClient {\n  /** {@inheritDoc HTTPClient.request} */\n  async request({\n    data,\n    headers: requestHeaders,\n    method,\n    url,\n  }: HTTPRequest): Promise<HTTPResponse> {\n    // TODO: handle client timeouts with AbortController. Emit NetworkError if so.\n\n    const response = await fetch(url, {\n      method,\n      headers: { ...requestHeaders, \"Content-Type\": \"application/json\" },\n      body: JSON.stringify(data),\n    }).catch((error) => {\n      throw new NetworkError(\"The network connection encountered a problem.\", {\n        cause: error,\n      });\n    });\n\n    const status = response.status;\n\n    const responseHeaders: Record<string, string> = {};\n    response.headers.forEach((value, key) => (responseHeaders[key] = value));\n\n    const body = await response.text();\n\n    return {\n      status,\n      body,\n      headers: responseHeaders,\n    };\n  }\n}\n", "// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport type { Client } from \"../client\";\nimport { QueryRequest } from \"../wire-protocol\";\nimport { FetchClient } from \"./fetch-client\";\nexport { FetchClient } from \"./fetch-client\";\n\n/**\n * An object representing an http request.\n * The {@link Client} provides this to the {@link HTTPClient} implementation.\n */\nexport type HTTPRequest = {\n  data: QueryRequest;\n  headers: Record<string, string>;\n  method: string;\n  url: string;\n};\n\n/**\n * An object representing an http request.\n * It is returned to, and handled by, the {@link Client}.\n */\nexport type HTTPResponse = {\n  body: string;\n  headers: Record<string, string | string[]>;\n  status: number;\n};\n\n/**\n * An interface to provide implementation-specific, asyncronous http calls.\n * This driver provides default implementations for common environments. Users\n * can configure the {@link Client} to use custom implementations if desired.\n */\nexport interface HTTPClient {\n  /**\n   * Makes an HTTP request and returns the response\n   * @param req - an {@link HTTPRequest}\n   * @returns A Promise&lt;{@link HTTPResponse}&gt;\n   */\n  request(req: HTTPRequest): Promise<HTTPResponse>;\n}\n\nexport const getDefaultHTTPClient = () => {\n  // WIP: we only have one implementation right now, but should eventually\n  // inspect the environment for the correct implementation\n  return new FetchClient();\n};\n\n// utility functions\n\nexport const isHTTPResponse = (res: any): res is HTTPResponse =>\n  res instanceof Object && \"body\" in res && \"headers\" in res && \"status\" in res;\n", "// Date and Time expressions\n\nconst yearpart = /(?:\\d{4}|[\\u2212-]\\d{4,}|\\+\\d{5,})/;\nconst monthpart = /(?:0[1-9]|1[0-2])/;\nconst daypart = /(?:0[1-9]|[12]\\d|3[01])/;\nconst hourpart = /(?:[01][0-9]|2[0-3])/;\nconst minsecpart = /(?:[0-5][0-9])/;\nconst decimalpart = /(?:\\.\\d+)/;\n\nconst datesplit = new RegExp(\n  `(${yearpart.source}-(${monthpart.source})-(${daypart.source}))`\n);\n\nconst timesplit = new RegExp(\n  `(${hourpart.source}:${minsecpart.source}:${minsecpart.source}${decimalpart.source}?)`\n);\n\nconst zonesplit = new RegExp(\n  `([zZ]|[+\\u2212-]${hourpart.source}(?::?${minsecpart.source}|:${minsecpart.source}:${minsecpart.source}))`\n);\n\n/**\n * Matches the subset of ISO8601 dates that Fauna can accept. Cannot include any\n * time part\n */\nexport const plaindate = new RegExp(`^${datesplit.source}$`);\n\n/**\n * Matches a valid ISO8601 date and can have anything trailing after.\n */\nexport const startsWithPlaindate = new RegExp(`^${datesplit.source}`);\n\n/**\n * Matches the subset of ISO8601 times that Fauna can accept.\n */\nexport const datetime = new RegExp(\n  `^${datesplit.source}T${timesplit.source}${zonesplit.source}$`\n);\n", "import { ClientError } from \"../errors\";\nimport * as PARSE from \"../regex\";\n\n/**\n * An wrapper around the Fauna `Time` type. It, represents a fixed point in time\n * without regard to calendar or location, e.g. July 20, 1969, at 20:17 UTC.\n * Convert to and from Javascript Date's with the {@link TimeStub.fromDate} and\n * {@link TimeStub.toDate} methods.\n * See remarks for possible precision loss when doing this. If precision loss is\n * a concern consider using a 3rd party datetime library such as luxon.\n *\n * @remarks The Javascript `Date` type most closely resembles a Fauna `Time`,\n * not a Fauna `Date`. However, Fauna stores `Time` values with nanosecond\n * precision, while Javascript `Date` values only have millisecond precision.\n * This TimeStub class preserves precision by storing the original string value\n * and should be used whenever possible to pass `Time` values back to Fauna.\n * Converting to a Javascript date before sending to Fauna could result in loss\n * of precision.\n *\n * @see {@link https://deploy-preview-1272--fauna-docs.netlify.app/fqlx/beta/reference/builtin_functions/time/time}\n */\nexport class TimeStub {\n  readonly isoString: string;\n\n  /**\n   * @remarks constructor is private to enforce using factory functions\n   */\n  private constructor(isoString: string) {\n    this.isoString = isoString;\n  }\n\n  /**\n   * Creates a new {@link TimeStub} from an ISO date string\n   * @param isoString - An ISO date string.\n   * @returns A new {@link TimeStub}\n   * @throws TypeError if a string is not provided, or RangeError if item\n   * is not a valid date\n   */\n  static from(isoString: string): TimeStub {\n    if (typeof isoString !== \"string\") {\n      throw new TypeError(\n        `Expected string but received ${typeof isoString}: ${isoString}`\n      );\n    }\n    const matches = PARSE.datetime.exec(isoString);\n    if (matches === null) {\n      throw new RangeError(\n        `(regex) Expected an ISO date string but received '${isoString}'`\n      );\n    }\n    // There are some dates that match the regex but are invalid, such as Feb 31.\n    // Javascript does not parse all years that are valid in fauna, so let\n    // Fauna be the final check.\n\n    return new TimeStub(isoString);\n  }\n\n  /**\n   * Creates a new {@link TimeStub} from a Javascript `Date`\n   * @param date - A Javascript `Date`\n   * @returns A new {@link TimeStub}\n   */\n  static fromDate(date: Date): TimeStub {\n    return new TimeStub(date.toISOString());\n  }\n\n  /**\n   * Get a copy of the `TimeStub` converted to a Javascript `Date`. Does not\n   * mutate the existing `TimeStub` value.\n   * @returns A `Date`\n   */\n  toDate(): Date {\n    const date = new Date(this.isoString);\n    if (date.toString() === \"Invalid Date\") {\n      throw new RangeError(\n        \"Fauna Date could not be converted to Javascript Date\"\n      );\n    }\n    return date;\n  }\n\n  /**\n   * Override default string conversion\n   * @returns the string representation of a `TimeStub`\n   */\n  toString(): string {\n    return `TimeStub(\"${this.isoString}\")`;\n  }\n}\n\n/**\n * A wrapper aroud the Fauna `Date` type. It represents a calendar date that is\n * not associated with a particular time or time zone, e.g. August 24th, 2006.\n * Convert to and from Javascript Date's with the {@link DateStub.fromDate} and\n * {@link DateStub.toDate} methods. Javascript Dates are rendered in UTC time\n * before the date part is used.\n * See remarks for possible precision loss when doing this. If precision loss is\n * a concern consider using a 3rd party datetime library such as luxon.\n *\n * @remarks The Javascript `Date` type always has a time associated with it, but\n * Fauna's `Date` type does not. When converting from a Fauna `Date` to a\n * Javascript `Date`, we set time to 00:00:00 UTC. When converting a Javascript\n * `Date` or time string to Fauna `Date`, we convert to UTC first. Care should\n * be taken to specify the desired date, since Javascript `Date`s use local\n * timezone info by default.\n *\n * @see {@link https://deploy-preview-1272--fauna-docs.netlify.app/fqlx/beta/reference/builtin_functions/date/date}\n */\nexport class DateStub {\n  readonly dateString: string;\n\n  /**\n   * @remarks constructor is private to enforce using factory functions\n   */\n  private constructor(dateString: string) {\n    this.dateString = dateString;\n  }\n\n  /**\n   * Creates a new {@link DateStub} from a date string\n   * @param dateString - A plain date string. The time is converted to UTC\n   * before saving the date.\n   * @returns A new {@link DateStub}\n   * @throws TypeError if a string is not provided, or RangeError if dateString\n   * is not a valid date\n   */\n  static from(dateString: string): DateStub {\n    if (typeof dateString !== \"string\") {\n      throw new TypeError(\n        `Expected string but received ${typeof dateString}: ${dateString}`\n      );\n    }\n    const matches = PARSE.plaindate.exec(dateString);\n    if (matches === null) {\n      throw new RangeError(\n        `Expected a plain date string but received '${dateString}'`\n      );\n    }\n    // There are some dates that match the regex but are invalid, such as Feb 31.\n    // Javascript does not parse all years that are valid in fauna, so let\n    // Fauna be the final check.\n\n    return new DateStub(matches[0]);\n  }\n\n  /**\n   * Creates a new {@link DateStub} from a Javascript `Date`\n   * @param date - A Javascript `Date`. The time is converted to UTC before\n   * saving the date.\n   * @returns A new {@link DateStub}\n   */\n  static fromDate(date: Date): DateStub {\n    const dateString = date.toISOString();\n    const matches = PARSE.startsWithPlaindate.exec(dateString);\n    if (matches === null) {\n      // Our regex should match any possible date that comes out of\n      // `Date.toISOString()`, so we will only get here if the regex is\n      // incorrect. This is a ClientError since it is our fault.\n      throw new ClientError(`Failed to parse date '${date}'`);\n    }\n    return new DateStub(matches[0]);\n  }\n\n  /**\n   * Get a copy of the `TimeStub` converted to a Javascript `Date`. Does not\n   * mutate the existing `TimeStub` value.\n   * @returns A `Date`\n   */\n  toDate(): Date {\n    const date = new Date(this.dateString + \"T00:00:00Z\");\n    if (date.toString() === \"Invalid Date\") {\n      throw new RangeError(\n        \"Fauna Date could not be converted to Javascript Date\"\n      );\n    }\n    return date;\n  }\n\n  /**\n   * Override default string conversion\n   * @returns the string representation of a `DateStub`\n   */\n  toString(): string {\n    return `DateStub(\"${this.dateString}\")`;\n  }\n}\n", "import { JSONObject } from \"../wire-protocol\";\nimport { TimeStub } from \"./date-time\";\n\n/**\n * A reference to a Document with an ID. The Document may or may not exist.\n * References to Keys, Tokens, and Documents in user-defined Collections are\n * modeled with a {@link DocumentReference}.\n *\n * @example\n * ```javascript\n *  const thingRef = await client.query(fql`\n *    Thing(\"101\")\n *  `);\n *\n *  const id = thingRef.id\n * ```\n */\nexport class DocumentReference {\n  readonly coll: Module;\n  readonly id: string;\n\n  constructor({ coll, id }: { coll: Module | string; id: string }) {\n    this.id = id;\n\n    if (typeof coll === \"string\") {\n      this.coll = new Module(coll);\n    } else {\n      this.coll = coll;\n    }\n  }\n}\n\n/**\n * A materialized Document with an ID. Keys, Tokens and Documents in\n * user-defined Collections are modeled with a {@link Document}. All top level\n * Document fields are added to a {@link Document} instance, but types cannot be\n * provided. Cast the instance to a {@link DocumentT} to have typesafe access to\n * all top level fields.\n *\n * @example\n * ```javascript\n *  const thing = await client.query(fql`\n *    Thing.byId(\"101\")\n *  `);\n *\n *  const color = thing.color\n * ```\n *\n * @remarks The {@link Document} class cannot be generic because classes cannot\n * extend generic type arguments.\n */\nexport class Document extends DocumentReference {\n  readonly ts: TimeStub;\n\n  constructor(obj: {\n    coll: Module | string;\n    id: string;\n    ts: TimeStub;\n    [key: string]: any;\n  }) {\n    const { coll, id, ts, ...rest } = obj;\n    super({ coll, id });\n    this.ts = ts;\n    Object.assign(this, rest);\n  }\n\n  toObject(): { coll: Module; id: string; ts: TimeStub } {\n    return { ...this } as { coll: Module; id: string; ts: TimeStub };\n  }\n}\n\n/**\n * A reference to a Document with a name. The Document may or may not exist.\n * References to specific AccessProviders, Collections, Databases, Functions, etc. are\n * modeled with a {@link NamedDocumentReference}.\n *\n * @example\n * ```javascript\n *  const thingCollection = await client.query(fql`\n *    Thing.definition\n *  `);\n *\n *  const id = thingCollection.id\n * ```\n */\nexport class NamedDocumentReference {\n  readonly coll: Module;\n  readonly name: string;\n\n  constructor({ coll, name }: { coll: Module | string; name: string }) {\n    this.name = name;\n\n    if (typeof coll === \"string\") {\n      this.coll = new Module(coll);\n    } else {\n      this.coll = coll;\n    }\n  }\n}\n\n/**\n * A materialized Document with a name. Specific AccessProviders, Collections, Databases,\n * Functions, etc. that include user defined data are modeled with a {@link NamedDocument}.\n *\n * @example\n * ```javascript\n *  const thingCollection = await client.query(fql`\n *    Thing.definition\n *  `);\n *\n *  const indexes = thingCollection.indexes\n * ```\n *\n * @example\n * All of the named Documents can have optional, user-defined data. The generic\n * class lets you define the shape of that data in a typesafe way\n * ```typescript\n *  type CollectionMetadata = {\n *    metadata: string\n *  }\n *\n *  const thingCollection = await client.query<NamedDocument<CollectionMetadata>>(fql`\n *    Thing.definition\n *  `);\n *\n *  const metadata = thingCollection.data.metadata\n * ```\n */\nexport class NamedDocument<\n  T extends JSONObject = Record<string, never>\n> extends NamedDocumentReference {\n  readonly ts: TimeStub;\n  readonly data: T;\n\n  constructor(obj: {\n    coll: Module | string;\n    name: string;\n    ts: TimeStub;\n    data?: T;\n  }) {\n    const { coll, name, ts, data, ...rest } = obj;\n    super({ coll, name });\n    this.ts = ts;\n    this.data = data || ({} as T);\n    Object.assign(this, rest);\n  }\n\n  toObject(): { coll: Module; name: string; ts: TimeStub; data: T } {\n    return { ...this } as { coll: Module; name: string; ts: TimeStub; data: T };\n  }\n}\n\n/**\n * A Fauna module, such as a Collection, Database, Function, Role, etc.\n *\n * @example\n * ```javascript\n *  const thingModule = await client.query(fql`\n *    Thing\n *  `);\n *\n *  const name = thingModule.name\n * ```\n */\nexport class Module {\n  readonly name: string;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n\n/**\n * A Document typed with a user-defined data type. Typescript users can cast\n * instances of {@link Document} to {@link DocumentT} to access user-defined fields with type safety.\n *\n * @example\n * ```typescript\n *  type Thing = {\n *    color: string\n *  }\n *\n *  const thing = await client.query<DocumentT<Thing>>(fql`\n *    Thing.byId(\"101\")\n *  `);\n *\n *  const color = thing.color\n * ```\n *\n * @remarks The {@link Document} class cannot be generic because classes cannot\n * extend generic type arguments.\n */\nexport type DocumentT<T extends JSONObject> = Document & T;\n", "import { JSONValue } from \"../wire-protocol\";\n\nexport class Set<T extends JSONValue> {\n  readonly data: T[];\n  readonly after?: string;\n\n  constructor({ data, after }: { data: T[]; after?: string }) {\n    this.data = data;\n    this.after = after;\n  }\n\n  // TODO: implement pagination helpers in this class\n}\n", "import {\n  DateStub,\n  Document,\n  DocumentReference,\n  Module,\n  NamedDocument,\n  NamedDocumentReference,\n  TimeStub,\n  Set,\n} from \"./values\";\nimport { JSONObject, JSONValue } from \"./wire-protocol\";\n\n/**\n * TaggedType provides the encoding/decoding of the Fauna Tagged Type formatting\n */\nexport class TaggedTypeFormat {\n  /**\n   * Encode the Object to the Tagged Type format for Fauna\n   *\n   * @param obj - Object that will be encoded\n   * @returns Map of result\n   */\n  static encode(obj: any): any {\n    return encode(obj);\n  }\n\n  /**\n   * Decode the JSON string result from Fauna to remove Tagged Type formatting.\n   *\n   * @param input - JSON string result from Fauna\n   * @returns object of result of FQL query\n   */\n  static decode(input: string): any {\n    return JSON.parse(input, (_, value: any) => {\n      if (value == null) return null;\n      if (value[\"@mod\"]) {\n        return new Module(value[\"@mod\"]);\n      } else if (value[\"@doc\"]) {\n        // WIP: The string-based ref is being removed from the API\n        if (typeof value[\"@doc\"] === \"string\") {\n          const [modName, id] = value[\"@doc\"].split(\":\");\n          return new DocumentReference({ coll: modName, id: id });\n        }\n        // if not a docref string, then it is an object.\n        const obj = value[\"@doc\"];\n        if (obj.id) {\n          return new Document(obj);\n        } else {\n          return new NamedDocument(obj);\n        }\n      } else if (value[\"@ref\"]) {\n        const obj = value[\"@ref\"];\n        if (obj.id) {\n          return new DocumentReference(obj);\n        } else {\n          return new NamedDocumentReference(obj);\n        }\n      } else if (value[\"@set\"]) {\n        return new Set(value[\"@set\"]);\n      } else if (value[\"@int\"]) {\n        return Number(value[\"@int\"]);\n      } else if (value[\"@long\"]) {\n        return BigInt(value[\"@long\"]);\n      } else if (value[\"@double\"]) {\n        return Number(value[\"@double\"]);\n      } else if (value[\"@date\"]) {\n        return DateStub.from(value[\"@date\"]);\n      } else if (value[\"@time\"]) {\n        return TimeStub.from(value[\"@time\"]);\n      } else if (value[\"@object\"]) {\n        return value[\"@object\"];\n      }\n\n      return value;\n    });\n  }\n}\n\ntype TaggedDate = { \"@date\": string };\ntype TaggedDouble = { \"@double\": string };\ntype TaggedInt = { \"@int\": string };\ntype TaggedLong = { \"@long\": string };\ntype TaggedMod = { \"@mod\": string };\ntype TaggedObject = { \"@object\": JSONObject };\ntype TaggedRef = {\n  \"@ref\": { id: string; coll: TaggedMod } | { name: string; coll: TaggedMod };\n};\ntype TaggedSet = { \"@set\": { data: JSONValue[]; after?: string } };\ntype TaggedTime = { \"@time\": string };\n\nexport const LONG_MIN = BigInt(\"-9223372036854775808\");\nexport const LONG_MAX = BigInt(\"9223372036854775807\");\n\nconst encodeMap = {\n  bigint: (value: bigint): TaggedLong => {\n    if (value < LONG_MIN || value > LONG_MAX) {\n      throw new RangeError(\n        \"Precision loss when converting BigInt to Fauna type\"\n      );\n    }\n\n    return {\n      \"@long\": value.toString(),\n    };\n  },\n  number: (value: number): TaggedDouble | TaggedInt | TaggedLong => {\n    if (\n      value === Number.POSITIVE_INFINITY ||\n      value === Number.NEGATIVE_INFINITY\n    ) {\n      throw new RangeError(`Cannot convert ${value} to a Fauna type.`);\n    }\n\n    if (`${value}`.includes(\".\")) {\n      return { \"@double\": value.toString() };\n    } else {\n      if (value >= -(2 ** 31) && value <= 2 ** 31 - 1) {\n        return { \"@int\": value.toString() };\n      } else if (Number.isSafeInteger(value)) {\n        return {\n          \"@long\": value.toString(),\n        };\n      }\n      return { \"@double\": value.toString() };\n    }\n  },\n  string: (value: string): string => {\n    return value;\n  },\n  object: (input: JSONObject): TaggedObject | JSONObject => {\n    let wrapped = false;\n    const _out: JSONObject = {};\n\n    for (const k in input) {\n      if (k.startsWith(\"@\")) {\n        wrapped = true;\n      }\n      _out[k] = encode(input[k]);\n    }\n    return wrapped ? { \"@object\": _out } : _out;\n  },\n  array: (input: Array<JSONValue>): Array<JSONValue> => {\n    const _out: JSONValue = [];\n    for (const i in input) _out.push(encode(input[i]));\n    return _out;\n  },\n  date: (dateValue: Date): TaggedTime => ({\n    \"@time\": dateValue.toISOString(),\n  }),\n  faunadate: (value: DateStub): TaggedDate => ({ \"@date\": value.dateString }),\n  faunatime: (value: TimeStub): TaggedTime => ({ \"@time\": value.isoString }),\n  module: (value: Module): TaggedMod => ({ \"@mod\": value.name }),\n  documentReference: (value: DocumentReference): TaggedRef => ({\n    \"@ref\": { id: value.id, coll: { \"@mod\": value.coll.name } },\n  }),\n  document: (value: Document): TaggedRef => ({\n    \"@ref\": { id: value.id, coll: { \"@mod\": value.coll.name } },\n  }),\n  namedDocumentReference: (value: NamedDocumentReference): TaggedRef => ({\n    \"@ref\": { name: value.name, coll: { \"@mod\": value.coll.name } },\n  }),\n  namedDocument: (value: NamedDocument): TaggedRef => ({\n    \"@ref\": { name: value.name, coll: { \"@mod\": value.coll.name } },\n  }),\n  set: (value: Set<any>): TaggedSet => ({\n    \"@set\": { data: encodeMap[\"array\"](value.data), after: value.after },\n  }),\n};\n\nconst encode = (input: JSONValue): JSONValue => {\n  switch (typeof input) {\n    case \"bigint\":\n      return encodeMap[\"bigint\"](input);\n    case \"string\":\n      return encodeMap[\"string\"](input);\n    case \"number\":\n      return encodeMap[\"number\"](input);\n    case \"object\":\n      if (input == null) {\n        return null;\n      } else if (Array.isArray(input)) {\n        return encodeMap[\"array\"](input);\n      } else if (input instanceof Date) {\n        return encodeMap[\"date\"](input);\n      } else if (input instanceof DateStub) {\n        return encodeMap[\"faunadate\"](input);\n      } else if (input instanceof TimeStub) {\n        return encodeMap[\"faunatime\"](input);\n      } else if (input instanceof Module) {\n        return encodeMap[\"module\"](input);\n      } else if (input instanceof DocumentReference) {\n        return encodeMap[\"documentReference\"](input);\n      } else if (input instanceof Document) {\n        return encodeMap[\"document\"](input);\n      } else if (input instanceof NamedDocumentReference) {\n        return encodeMap[\"namedDocumentReference\"](input);\n      } else if (input instanceof NamedDocument) {\n        return encodeMap[\"namedDocument\"](input);\n      } else if (input instanceof Set) {\n        return encodeMap[\"set\"](input);\n      } else {\n        return encodeMap[\"object\"](input);\n      }\n      break;\n  }\n  // default to encoding directly as the input\n  return input;\n};\n", "import { ClientConfiguration, endpoints } from \"./client-configuration\";\nimport {\n  AuthenticationError,\n  AuthorizationError,\n  ClientError,\n  NetworkError,\n  ProtocolError,\n  QueryCheckError,\n  QueryRuntimeError,\n  QueryTimeoutError,\n  ServiceError,\n  ServiceInternalError,\n  ServiceTimeoutError,\n  ThrottlingError,\n} from \"./errors\";\nimport type { QueryBuilder } from \"./query-builder\";\nimport {\n  isQueryFailure,\n  isQuerySuccess,\n  type QueryFailure,\n  type QueryRequest,\n  type QueryRequestHeaders,\n  type QuerySuccess,\n} from \"./wire-protocol\";\nimport {\n  getDefaultHTTPClient,\n  isHTTPResponse,\n  type HTTPClient,\n} from \"./http-client\";\nimport { TaggedTypeFormat } from \"./tagged-type\";\n\nconst defaultClientConfiguration: Pick<\n  ClientConfiguration,\n  \"endpoint\" | \"max_conns\"\n> = {\n  endpoint: endpoints.cloud,\n  max_conns: 10,\n};\n\n/**\n * Client for calling Fauna.\n */\nexport class Client {\n  /** The {@link ClientConfiguration} */\n  readonly #clientConfiguration: ClientConfiguration;\n  /** The underlying {@link HTTPClient} client. */\n  readonly #httpClient: HTTPClient;\n  /** The last transaction timestamp this client has seen */\n  #lastTxnTs?: number;\n  /** url of Fauna */\n  #url: string;\n\n  /**\n   * Constructs a new {@link Client}.\n   * @param clientConfiguration - the {@link ClientConfiguration} to apply. Defaults to recommended ClientConfiguraiton.\n   * @param httpClient - The underlying {@link HTTPClient} that will execute the actual HTTP calls. Defaults to recommended HTTPClient.\n   * @example\n   * ```typescript\n   *  const myClient = new Client(\n   *   {\n   *     endpoint: endpoints.cloud,\n   *     max_conns: 10,\n   *     secret: \"foo\",\n   *     query_timeout_ms: 60_000,\n   *   }\n   * );\n   * ```\n   */\n  constructor(\n    clientConfiguration?: Partial<ClientConfiguration>,\n    httpClient?: HTTPClient\n  ) {\n    this.#clientConfiguration = {\n      ...defaultClientConfiguration,\n      ...clientConfiguration,\n      secret: this.#getSecret(clientConfiguration),\n    };\n    this.#url = `${this.clientConfiguration.endpoint.toString()}query/1`;\n    if (!httpClient) {\n      this.#httpClient = getDefaultHTTPClient();\n    } else {\n      this.#httpClient = httpClient;\n    }\n  }\n\n  /**\n   * @returns the last transaction time seen by this client, or undefined if this client has not seen a transaction time.\n   */\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore it's okay that #lastTxnTs could be undefined on get, but we want\n  //   to enforce that the user never intentionally set it to undefined.\n  get lastTxnTs(): number | undefined {\n    return this.#lastTxnTs;\n  }\n  /**\n   * Sets the last transaction time of this client.\n   * @param ts - the last transaction timestamp to set, as microseconds since\n   *   the epoch. If `ts` is less than the existing `#lastTxnTs` value, then no\n   *   change is made.\n   */\n  set lastTxnTs(ts: number) {\n    this.#lastTxnTs = this.#lastTxnTs ? Math.max(ts, this.#lastTxnTs) : ts;\n  }\n\n  /**\n   * Return the {@link ClientConfiguration} of this client, save for the secret.\n   */\n  get clientConfiguration(): Omit<ClientConfiguration, \"secret\"> {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const { secret, ...rest } = this.#clientConfiguration;\n    return rest;\n  }\n\n  /**\n   * Queries Fauna.\n   * @param request - a {@link QueryRequest} or {@link QueryBuilder} to build a request with.\n   *  Note, you can embed header fields in this object; if you do that there's no need to\n   *  pass the headers parameter.\n   * @param headers - optional {@link QueryRequestHeaders} to apply on top of the request input.\n   *   Values in this headers parameter take precedence over the same values in the request\n   *   parameter. This field is primarily intended to be used when you pass a QueryBuilder as\n   *   the parameter.\n   * @returns Promise&lt;{@link QuerySuccess}&gt;.\n   * @throws {@link ServiceError} Fauna emitted an error. The ServiceError will be\n   *   one of ServiceError's child classes if the error can be further categorized,\n   *   or a concrete ServiceError if it cannot. ServiceError child types are\n   *   {@link AuthenticaionError}, {@link AuthorizationError}, {@link QueryCheckError}\n   *   {@link QueryRuntimeError}, {@link QueryTimeoutError}, {@link ServiceInternalError}\n   *   {@link ServiceTimeoutError}, {@link ThrottlingError}.\n   *   You can use either the type, or the underlying httpStatus + code to determine\n   *   the root cause.\n   * @throws {@link ProtocolError} the client a HTTP error not sent by Fauna.\n   * @throws {@link NetworkError} the client encountered a network issue\n   * connecting to Fauna.\n   * @throws A {@link ClientError} the client fails to submit the request\n   * due to an internal error.\n   */\n  async query<T = any>(\n    request: QueryRequest | QueryBuilder,\n    headers?: QueryRequestHeaders\n  ): Promise<QuerySuccess<T>> {\n    if (\"query\" in request) {\n      return this.#query({ ...request, ...headers });\n    }\n    return this.#query(request.toQuery(headers));\n  }\n\n  #getError(e: any): ClientError | NetworkError | ProtocolError | ServiceError {\n    // the error was already handled by the driver\n    if (\n      e instanceof ClientError ||\n      e instanceof NetworkError ||\n      e instanceof ProtocolError ||\n      e instanceof ServiceError\n    ) {\n      return e;\n    }\n\n    // the HTTP request succeeded, but there was an error\n    if (isHTTPResponse(e)) {\n      // we got an error from the fauna service\n      if (isQueryFailure(e.body)) {\n        const failure = e.body;\n        const status = e.status;\n        return this.#getServiceError(failure, status);\n      }\n\n      // we got a different error from the protocol layer\n      return new ProtocolError({\n        message: `Response is in an unkown format: ${e.body}`,\n        httpStatus: e.status,\n      });\n    }\n\n    // unknown error\n    return new ClientError(\n      \"A client level error occurred. Fauna was not called.\",\n      {\n        cause: e,\n      }\n    );\n  }\n\n  #getSecret(partialClientConfig?: Partial<ClientConfiguration>): string {\n    let fallback = undefined;\n    if (typeof process === \"object\") {\n      fallback = process.env[\"FAUNA_SECRET\"];\n    }\n    const maybeSecret = partialClientConfig?.secret || fallback;\n    if (maybeSecret === undefined) {\n      throw new Error(\n        \"You must provide a secret to the driver. Set it \\\nin an environmental variable named FAUNA_SECRET or pass it to the Client\\\n constructor.\"\n      );\n    }\n    return maybeSecret;\n  }\n\n  #getServiceError(failure: QueryFailure, httpStatus: number): ServiceError {\n    switch (httpStatus) {\n      case 400:\n        if (\n          httpStatus === 400 &&\n          queryCheckFailureCodes.includes(failure.error.code)\n        ) {\n          return new QueryCheckError(failure, httpStatus);\n        }\n\n        return new QueryRuntimeError(failure, httpStatus);\n      case 401:\n        return new AuthenticationError(failure, httpStatus);\n      case 403:\n        return new AuthorizationError(failure, httpStatus);\n      case 429:\n        return new ThrottlingError(failure, httpStatus);\n      case 440:\n        return new QueryTimeoutError(failure, httpStatus);\n      case 500:\n        return new ServiceInternalError(failure, httpStatus);\n      case 503:\n        return new ServiceTimeoutError(failure, httpStatus);\n      default:\n        return new ServiceError(failure, httpStatus);\n    }\n  }\n\n  async #query<T = any>(queryRequest: QueryRequest): Promise<QuerySuccess<T>> {\n    try {\n      const headers = {\n        Authorization: `Bearer ${this.#clientConfiguration.secret}`,\n      };\n      this.#setHeaders(\n        { ...this.clientConfiguration, ...queryRequest },\n        headers\n      );\n\n      const isTaggedFormat =\n        (this.#clientConfiguration.format ?? \"tagged\") === \"tagged\" ||\n        queryRequest.format === \"tagged\";\n      const queryArgs = isTaggedFormat\n        ? TaggedTypeFormat.encode(queryRequest.arguments)\n        : queryRequest.arguments;\n\n      const requestData = {\n        query: queryRequest.query,\n        arguments: queryArgs,\n      };\n\n      const fetchResponse = await this.#httpClient.request({\n        url: this.#url,\n        method: \"POST\",\n        headers,\n        data: requestData,\n      });\n\n      let parsedResponse;\n      try {\n        parsedResponse = {\n          ...fetchResponse,\n          body: isTaggedFormat\n            ? TaggedTypeFormat.decode(fetchResponse.body)\n            : JSON.parse(fetchResponse.body),\n        };\n        if (parsedResponse.body.query_tags) {\n          const tags_array = (parsedResponse.body.query_tags as string)\n            .split(\",\")\n            .map((tag) => tag.split(\"=\"));\n          parsedResponse.body.query_tags = Object.fromEntries(tags_array);\n        }\n      } catch (error: unknown) {\n        throw new ProtocolError({\n          message: `Error parsing response as JSON: ${error}`,\n          httpStatus: fetchResponse.status,\n        });\n      }\n\n      // Response is not from Fauna\n      if (!isQuerySuccess(parsedResponse.body)) {\n        throw this.#getError(parsedResponse);\n      }\n\n      const txn_ts = parsedResponse.body.txn_ts;\n      if (\n        (this.#lastTxnTs === undefined && txn_ts !== undefined) ||\n        (txn_ts !== undefined &&\n          this.#lastTxnTs !== undefined &&\n          this.#lastTxnTs < txn_ts)\n      ) {\n        this.#lastTxnTs = txn_ts;\n      }\n\n      return parsedResponse.body as QuerySuccess<T>;\n    } catch (e: any) {\n      throw this.#getError(e);\n    }\n  }\n\n  #setHeaders(fromObject: QueryRequestHeaders, headerObject: any): void {\n    for (const entry of Object.entries(fromObject)) {\n      if (\n        [\n          \"format\",\n          \"query_timeout_ms\",\n          \"linearized\",\n          \"max_contention_retries\",\n          \"traceparent\",\n          \"typecheck\",\n          \"query_tags\",\n        ].includes(entry[0])\n      ) {\n        let headerValue: string;\n        let headerKey = `x-${entry[0].replaceAll(\"_\", \"-\")}`;\n        if (\"query_tags\" === entry[0]) {\n          headerValue = Object.entries(entry[1])\n            .map((tag) => tag.join(\"=\"))\n            .join(\",\");\n        } else {\n          if (typeof entry[1] === \"string\") {\n            headerValue = entry[1];\n          } else {\n            headerValue = String(entry[1]);\n          }\n        }\n        if (\"traceparent\" === entry[0]) {\n          headerKey = entry[0];\n        }\n        headerObject[headerKey] = headerValue;\n      }\n    }\n    if (\n      headerObject[\"x-last-txn-ts\"] === undefined &&\n      this.#lastTxnTs !== undefined\n    ) {\n      headerObject[\"x-last-txn-ts\"] = this.#lastTxnTs;\n    }\n  }\n}\n\n// Private types and constants for internal logic.\n\nconst queryCheckFailureCodes = [\n  \"invalid_function_definition\",\n  \"invalid_identifier\",\n  \"invalid_query\",\n  \"invalid_syntax\",\n  \"invalid_type\",\n];\n", "import { TaggedTypeFormat } from \"./tagged-type\";\nimport type {\n  JSONObject,\n  JSONValue,\n  QueryInterpolation,\n  QueryRequest,\n  QueryRequestHeaders,\n} from \"./wire-protocol\";\n\nexport interface QueryBuilder {\n  toQuery: (headers?: QueryRequestHeaders) => QueryRequest;\n}\n\nexport const isQueryBuilder = (obj: any): obj is QueryBuilder =>\n  obj instanceof Object && typeof obj.toQuery === \"function\";\n\n/**\n * Creates a new QueryBuilder. Accepts template literal inputs.\n * @param queryFragments - a {@link TemplateStringsArray} that constitute\n *   the strings that are the basis of the query.\n * @param queryArgs - an Array\\<JSONValue | QueryBuilder\\> that\n *   constitute the arguments to inject between the queryFragments.\n * @throws Error - if you call this method directly (not using template\n *   literals) and pass invalid construction parameters\n * @example\n * ```typescript\n *  const str = \"baz\";\n *  const num = 17;\n *  const innerQueryBuilder = fql`${num} + 3)`;\n *  const queryRequestBuilder = fql`${str}.length == ${innerQueryBuilder}`;\n * ```\n */\nexport function fql(\n  queryFragments: TemplateStringsArray,\n  ...queryArgs: (JSONValue | QueryBuilder)[]\n): QueryBuilder {\n  return new TemplateQueryBuilder(queryFragments, ...queryArgs);\n}\n\n/**\n * Internal class.\n * A builder for composing queries using the {@link fql} tagged template\n * function\n */\nclass TemplateQueryBuilder implements QueryBuilder {\n  readonly #queryFragments: TemplateStringsArray;\n  readonly #queryArgs: (JSONValue | QueryBuilder)[];\n\n  constructor(\n    queryFragments: TemplateStringsArray,\n    ...queryArgs: (JSONValue | QueryBuilder)[]\n  ) {\n    if (\n      queryFragments.length === 0 ||\n      queryFragments.length !== queryArgs.length + 1\n    ) {\n      throw new Error(\"invalid query constructed\");\n    }\n    this.#queryFragments = queryFragments;\n    this.#queryArgs = queryArgs;\n  }\n\n  /**\n   * Converts this TemplateQueryBuilder to a {@link QueryRequest} you can send\n   * to Fauna.\n   * @param requestHeaders - optional {@link QueryRequestHeaders} to include\n   *   in the request (and thus override the defaults in your {@link ClientConfiguration}.\n   *   If not passed in, no headers will be set as overrides.\n   * @returns a {@link QueryRequest}.\n   * @example\n   * ```typescript\n   *  const num = 8;\n   *  const queryBuilder = fql`'foo'.length == ${num}`;\n   *  const queryRequest = queryBuilder.toQuery();\n   *  // produces:\n   *  { query: { fql: [\"'foo'.length == \", { value: { \"@int\": \"8\" } }, \"\"] }}\n   * ```\n   */\n  toQuery(requestHeaders: QueryRequestHeaders = {}): QueryRequest {\n    return { ...this.#render(requestHeaders), ...requestHeaders };\n  }\n\n  #render(requestHeaders: QueryRequestHeaders): QueryRequest {\n    if (this.#queryFragments.length === 1) {\n      return { query: { fql: [this.#queryFragments[0]] }, arguments: {} };\n    }\n\n    let resultArgs: JSONObject = {};\n    const renderedFragments: (string | QueryInterpolation)[] =\n      this.#queryFragments.flatMap((fragment, i) => {\n        // There will always be one more fragment than there are arguments\n        if (i === this.#queryFragments.length - 1) {\n          return fragment === \"\" ? [] : [fragment];\n        }\n\n        const arg = this.#queryArgs[i];\n        let subQuery: string | QueryInterpolation;\n        if (isQueryBuilder(arg)) {\n          const request = arg.toQuery(requestHeaders);\n          subQuery = request.query;\n          resultArgs = { ...resultArgs, ...request.arguments };\n        } else {\n          // arguments in the template format must always be encoded, regardless\n          // of the \"x-format\" request header\n          // TODO: catch and rethrow Errors, indicating bad user input\n          subQuery = { value: TaggedTypeFormat.encode(arg) };\n        }\n\n        return [fragment, subQuery].filter((x) => x !== \"\");\n      });\n\n    return {\n      query: { fql: renderedFragments },\n      arguments: resultArgs,\n    };\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
