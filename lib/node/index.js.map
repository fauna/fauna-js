{
  "version": 3,
  "sources": ["../../src/index.ts", "../../src/client-configuration.ts", "../../src/fetch.ts", "../../src/wire-protocol.ts", "../../src/client.ts", "../../src/query-builder.ts"],
  "sourcesContent": ["export { Client } from \"./client\";\nexport {\n  type ClientConfiguration,\n  type Endpoints,\n  endpoints,\n} from \"./client-configuration\";\nexport { type QueryBuilder, fql } from \"./query-builder\";\nexport {\n  AuthenticationError,\n  AuthorizationError,\n  ClientError,\n  NetworkError,\n  ProtocolError,\n  QueryCheckError,\n  QueryRuntimeError,\n  QueryTimeoutError,\n  ServiceError,\n  ServiceInternalError,\n  ServiceTimeoutError,\n  ThrottlingError,\n  type JSONObject,\n  type JSONValue,\n  type QueryRequest,\n  type QueryRequestHeaders,\n  type QuerySuccess,\n  type Span,\n} from \"./wire-protocol\";\n", "import type { FaunaFetch } from \"./fetch\";\n\n/**\n * Configuration for a client.\n */\nexport interface ClientConfiguration {\n  /**\n   * The {@link URL} of Fauna to call. See {@link endpoints} for some default options.\n   */\n  endpoint: URL;\n  /**\n   * The maximum number of connections to a make to Fauna.\n   */\n  max_conns: number;\n  /**\n   * A secret for your Fauna DB, used to authorize your queries.\n   * @see https://docs.fauna.com/fauna/current/security/keys\n   */\n  secret: string;\n  /**\n   * The timeout of each query, in milliseconds. This controls the maximum amount of\n   * time Fauna will execute your query before marking it failed.\n   */\n  timeout_ms: number;\n  /**\n   * If true, unconditionally run the query as strictly serialized.\n   * This affects read-only transactions. Transactions which write\n   * will always be strictly serialized.\n   */\n  linearized?: boolean;\n  /**\n   * The max number of times to retry the query if contention is encountered.\n   */\n  max_contention_retries?: number;\n\n  /**\n   * Tags provided back via logging and telemetry.\n   */\n  tags?: { [key: string]: string };\n  /**\n   * A traceparent provided back via logging and telemetry.\n   * Must match format: https://www.w3.org/TR/trace-context/#traceparent-header\n   */\n  traceparent?: string;\n\n  /**\n   * Wrapper for the HTTP requests, modeled after the web API. Can be provided by the user.\n   */\n  fetch: FaunaFetch;\n}\n\n/**\n * An extensible interface for a set of Fauna endpoints.\n * @remarks Leverage the `[key: string]: URL;` field to extend to other endpoints.\n */\nexport interface Endpoints {\n  /** Fauna's cloud endpoint. */\n  cloud: URL;\n  /** Fauna's preview endpoint for testing new features - requires beta access. */\n  preview: URL;\n  /**\n   * An endpoint for interacting with local instance of Fauna (e.g. one running in a local docker container).\n   */\n  local: URL;\n  /**\n   * An alias for local.\n   */\n  localhost: URL;\n  /**\n   * Any other endpoint you want your client to support. For example, if you run all requests through a proxy\n   * configure it here. Most clients will not need to leverage this ability.\n   */\n  [key: string]: URL;\n}\n\n/**\n * A extensible set of endpoints for calling Fauna.\n * @remarks Most clients will will not need to extend this set.\n * @example\n * ## To Extend\n * ```typescript\n *   // add to the endpoints constant\n *   endpoints.myProxyEndpoint = new URL(\"https://my.proxy.url\");\n * ```\n */\nexport const endpoints: Endpoints = {\n  cloud: new URL(\"https://db.fauna.com\"),\n  preview: new URL(\"https://db.fauna-preview.com\"),\n  local: new URL(\"http://localhost:8443\"),\n  localhost: new URL(\"http://localhost:8443\"),\n};\n", "/** following reference needed to include types for experimental fetch API in Node */\n/// <reference lib=\"dom\" />\n\nimport type { QueryFailure, QuerySuccess } from \"./wire-protocol\";\n\nexport type FetchOptions = {\n  body?: string;\n  keepalive?: true;\n  method?: string;\n  headers?: Record<string, string>;\n};\n\nexport type FetchResponse<T> = {\n  // headers: Record<string, string>,\n  status: number;\n  body: QuerySuccess<T> | QueryFailure;\n};\n\nexport type FaunaFetch = <T>(\n  resource: string | URL,\n  options: FetchOptions\n) => Promise<FetchResponse<T>>;\n\nexport const DefaultFetch: FaunaFetch = async <T>(\n  resource: string | URL,\n  options: FetchOptions\n): Promise<FetchResponse<T>> => {\n  const response = await fetch(resource, options);\n  const status = response.status;\n  const body = (await response.json()) as QuerySuccess<T> | QueryFailure;\n\n  // TODO: include headers. typing for Headers.entries not available?\n  // const headers = response.headers\n  // const headersObj = Object.fromEntries(headers.entries())\n\n  return {\n    status,\n    body,\n  };\n};\n", "/**\n * A request to make to Fauna.\n */\nexport interface QueryRequest extends QueryRequestHeaders {\n  /** The query. */\n  query: string;\n\n  /** Optional arguments if your query is interpolated. */\n  arguments?: JSONObject;\n}\n\nexport interface QueryRequestHeaders {\n  /**\n   * The ISO-8601 timestamp of the last transaction the client has previously observed.\n   * This client will track this by default, however, if you wish to override\n   * this value for a given request set this value.\n   */\n  last_txn?: string;\n  /**\n   * If true, unconditionally run the query as strictly serialized.\n   * This affects read-only transactions. Transactions which write\n   * will always be strictly serialized.\n   * Overrides the optional setting for the client.\n   */\n  linearized?: boolean;\n  /**\n   * The timeout to use in this query in milliseconds.\n   * Overrides the timeout for the client.\n   */\n  timeout_ms?: number;\n  /**\n   * The max number of times to retry the query if contention is encountered.\n   * Overrides the optional setting for the client.\n   */\n  max_contention_retries?: number;\n\n  /**\n   * Tags provided back via logging and telemetry.\n   * Overrides the optional setting on the client.\n   */\n  tags?: { [key: string]: string };\n  /**\n   * A traceparent provided back via logging and telemetry.\n   * Must match format: https://www.w3.org/TR/trace-context/#traceparent-header\n   * Overrides the optional setting for the client.\n   */\n  traceparent?: string;\n}\n\nexport type QueryInfo = {\n  /** Stats on query performance and cost */\n  stats: { [key: string]: number };\n  /** The last transaction time of the query. An ISO-8601 date string. */\n  txn_time: string;\n  /** A readable summary of any warnings or logs emitted by the query. */\n  summary?: string;\n  /** The query's inferred static result type. */\n  static_type?: string;\n};\n\nexport type QuerySuccess<T> = QueryInfo & {\n  /**\n   * The result of the query. The data is any valid JSON value.\n   * @remarks\n   * data is type parameterized so that you can treat it as a\n   * certain type if you are using typescript.\n   */\n  data: T;\n};\n\n/**\n * A failed query response. Integrations which only want to report a human\n * readable version of the failure can simply print out the \"summary\" field.\n */\nexport type QueryFailure = QueryInfo & {\n  /**\n   * The result of the query resulting in\n   */\n  error: {\n    /** A predefined code which indicates the type of error. See XXX for a list of error codes. */\n    code: string;\n    /** description: A short, human readable description of the error */\n    message: string;\n  };\n};\n\nexport const queryResponseIsSuccess = <T>(\n  res: QuerySuccess<T> | QueryFailure\n): res is QuerySuccess<T> => \"data\" in res;\n\nexport const queryResponseIsFailure = (\n  res: QuerySuccess<any> | QueryFailure\n): res is QueryFailure => \"error\" in res;\n\n/**\n * An error representing a query failure returned by Fauna.\n */\nexport class ServiceError extends Error {\n  /**\n   * The HTTP Status Code of the error.\n   */\n  readonly httpStatus: number;\n  /**\n   * A code for the error. Codes indicate the cause of the error.\n   * It is safe to write programmatic logic against the code. They are\n   * part of the API contract.\n   */\n  readonly code: string;\n  /**\n   * A summary of the error in a human readable form. Only present\n   * where message does not suffice.\n   */\n  readonly summary?: string;\n\n  constructor(httpStatus: number, failure: QueryFailure) {\n    super(failure.error.message);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ServiceError);\n    }\n\n    this.name = \"ServiceError\";\n    this.code = failure.error.code;\n    this.httpStatus = httpStatus;\n    if (failure.summary) {\n      this.summary = failure.summary;\n    }\n  }\n}\n\n/**\n * An error response that is the result of the query failing during execution.\n * QueryRuntimeError's occur when a bug in your query causes an invalid execution\n * to be requested.\n * The 'code' field will vary based on the specific error cause.\n */\nexport class QueryRuntimeError extends ServiceError {\n  constructor(httpStatus: number, failure: QueryFailure) {\n    super(httpStatus, failure);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, QueryRuntimeError);\n    }\n    this.name = \"QueryRuntimeError\";\n    // TODO trace, txn_time, and stats not yet returned for QueryRuntimeError\n    // flip to check for those rather than a specific code.\n  }\n}\n\n/**\n * An error due to a \"compile-time\" check of the query\n * failing.\n */\nexport class QueryCheckError extends ServiceError {\n  constructor(httpStatus: number, failure: QueryFailure) {\n    super(httpStatus, failure);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, QueryCheckError);\n    }\n    this.name = \"QueryCheckError\";\n  }\n}\n\n/**\n * A failure due to the timeout being exceeded, but the timeout\n * was set lower than the query's expected processing time.\n * This response is distinguished from a ServiceTimeoutException\n * in that a QueryTimeoutError shows Fauna behaving in an expected\n * manner.\n */\nexport class QueryTimeoutError extends ServiceError {\n  /**\n   * Statistics regarding the query.\n   */\n  readonly stats?: { [key: string]: number };\n\n  constructor(httpStatus: number, failure: QueryFailure) {\n    super(httpStatus, failure);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, QueryTimeoutError);\n    }\n    this.name = \"QueryTimeoutError\";\n    this.stats = failure.stats;\n  }\n}\n\n/**\n * AuthenticationError indicates invalid credentials were\n * used.\n */\nexport class AuthenticationError extends ServiceError {\n  constructor(httpStatus: number, failure: QueryFailure) {\n    super(httpStatus, failure);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AuthenticationError);\n    }\n    this.name = \"AuthenticationError\";\n  }\n}\n\n/**\n * AuthorizationError indicates the credentials used do not have\n * permission to perform the requested action.\n */\nexport class AuthorizationError extends ServiceError {\n  constructor(httpStatus: number, failure: QueryFailure) {\n    super(httpStatus, failure);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AuthorizationError);\n    }\n    this.name = \"AuthorizationError\";\n  }\n}\n\n/**\n * ThrottlingError indicates some capacity limit was exceeded\n * and thus the request could not be served.\n */\nexport class ThrottlingError extends ServiceError {\n  constructor(httpStatus: number, failure: QueryFailure) {\n    super(httpStatus, failure);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ThrottlingError);\n    }\n    this.name = \"ThrottlingError\";\n  }\n}\n\n/**\n * ServiceInternalError indicates Fauna failed unexpectedly.\n */\nexport class ServiceInternalError extends ServiceError {\n  constructor(httpStatus: number, failure: QueryFailure) {\n    super(httpStatus, failure);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ServiceInternalError);\n    }\n    this.name = \"ServiceInternalError\";\n  }\n}\n\n/**\n * ServiceTimeoutError indicates Fauna was not available to servce\n * the request before the timeout was reached.\n */\nexport class ServiceTimeoutError extends ServiceError {\n  constructor(httpStatus: number, failure: QueryFailure) {\n    super(httpStatus, failure);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ServiceTimeoutError);\n    }\n    this.name = \"ServiceTimeoutError\";\n  }\n}\n\n/**\n * An error representing a failure internal to the client, itself.\n * This indicates Fauna was never called - the client failed internally\n * prior to sending the qreuest.\n */\nexport class ClientError extends Error {\n  constructor(message: string, options: { cause: any }) {\n    super(message, options);\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ClientError);\n    }\n    this.name = \"ClientError\";\n  }\n}\n\n/**\n * An error representing a failure due to the network.\n * This indicates Fauna was never reached.\n */\nexport class NetworkError extends Error {\n  constructor(message: string, options: { cause: any }) {\n    super(message, options);\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, NetworkError);\n    }\n    this.name = \"NetworkError\";\n  }\n}\n\n/**\n * An error representing a HTTP failure - but one not directly\n * emitted by Fauna.\n */\nexport class ProtocolError extends Error {\n  /**\n   * The HTTP Status Code of the error.\n   */\n  readonly httpStatus: number;\n\n  constructor(error: { message: string; httpStatus: number }) {\n    super(error.message);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ProtocolError);\n    }\n\n    this.name = \"ProtocolError\";\n    this.httpStatus = error.httpStatus;\n  }\n}\n\n/**\n * A source span indicating a segment of FQL.\n */\nexport interface Span {\n  /**\n   * A string identifier of the FQL source. For example, if performing\n   * a raw query against the API this would be *query*.\n   */\n  src: string;\n  /**\n   * The span's starting index within the src, inclusive.\n   */\n  start: number;\n  /**\n   * The span's ending index within the src, inclusive.\n   */\n  end: number;\n  /**\n   * The name of the enclosing function, if applicable.\n   */\n  function: string;\n}\n\n/**\n * All objects returned from Fauna are valid JSON objects.\n */\nexport type JSONObject = {\n  [key: string]: JSONValue;\n};\n\n/**\n * All values returned from Fauna are valid JSON values.\n */\nexport type JSONValue =\n  | null\n  | string\n  | number\n  | boolean\n  | JSONObject\n  | Array<JSONValue>;\n", "import { ClientConfiguration, endpoints } from \"./client-configuration\";\nimport { DefaultFetch } from \"./fetch\";\nimport type { QueryBuilder } from \"./query-builder\";\nimport {\n  AuthenticationError,\n  AuthorizationError,\n  ClientError,\n  NetworkError,\n  ProtocolError,\n  QueryCheckError,\n  QueryRuntimeError,\n  QueryTimeoutError,\n  ServiceError,\n  ServiceInternalError,\n  ServiceTimeoutError,\n  ThrottlingError,\n  type QueryRequest,\n  type QueryRequestHeaders,\n  type QuerySuccess,\n  type QueryFailure,\n  queryResponseIsFailure,\n} from \"./wire-protocol\";\n\nconst defaultClientConfiguration = {\n  max_conns: 10,\n  endpoint: endpoints.cloud,\n  timeout_ms: 60_000,\n  fetch: DefaultFetch,\n};\n\n/**\n * Client for calling Fauna.\n */\nexport class Client {\n  /** The {@link ClientConfiguration} */\n  readonly clientConfiguration: ClientConfiguration;\n  /** last_txn this client has seen */\n  #lastTxn?: Date;\n\n  /**\n   * Constructs a new {@link Client}.\n   * @param clientConfiguration - the {@link ClientConfiguration} to apply.\n   * @example\n   * ```typescript\n   *  const myClient = new Client(\n   *   {\n   *     endpoint: endpoints.cloud,\n   *     max_conns: 10,\n   *     secret: \"foo\",\n   *     timeout_ms: 60_000,\n   *   }\n   * );\n   * ```\n   */\n  constructor(clientConfiguration?: Partial<ClientConfiguration>) {\n    this.clientConfiguration = {\n      ...defaultClientConfiguration,\n      ...clientConfiguration,\n      secret: this.#getSecret(clientConfiguration),\n    };\n  }\n\n  #getSecret(partialClientConfig?: Partial<ClientConfiguration>): string {\n    let fallback = undefined;\n    if (typeof process === \"object\") {\n      fallback = process.env[\"FAUNA_SECRET\"];\n    }\n    const maybeSecret = partialClientConfig?.secret || fallback;\n    if (maybeSecret === undefined) {\n      throw new Error(\n        \"You must provide a secret to the driver. Set it \\\nin an environmental variable named FAUNA_SECRET or pass it to the Client\\\n constructor.\"\n      );\n    }\n    return maybeSecret;\n  }\n\n  /**\n   * Queries Fauna.\n   * @param request - a {@link QueryRequest} or {@link QueryBuilder} to build a request with.\n   *  Note, you can embed header fields in this object; if you do that there's no need to\n   *  pass the headers parameter.\n   * @param headers - optional {@link QueryRequestHeaders} to apply on top of the request input.\n   *   Values in this headers parameter take precedence over the same values in the request\n   *   parameter. This field is primarily intended to be used when you pass a QueryBuilder as\n   *   the parameter.\n   * @returns Promise&lt;{@link QuerySuccess}&gt;.\n   * @throws {@link ServiceError} Fauna emitted an error. The ServiceError will be\n   *   one of ServiceError's child classes if the error can be further categorized,\n   *   or a concrete ServiceError if it cannot. ServiceError child types are\n   *   {@link AuthenticaionError}, {@link AuthorizationError}, {@link QueryCheckError}\n   *   {@link QueryRuntimeError}, {@link QueryTimeoutError}, {@link ServiceInternalError}\n   *   {@link ServiceTimeoutError}, {@link ThrottlingError}.\n   *   You can use either the type, or the underlying httpStatus + code to determine\n   *   the root cause.\n   * @throws {@link ProtocolError} the client a HTTP error not sent by Fauna.\n   * @throws {@link NetworkError} the client encountered a network issue\n   * connecting to Fauna.\n   * @throws A {@link ClientError} the client fails to submit the request\n   * due to an internal error.\n   */\n  async query<T = any>(\n    request: QueryRequest | QueryBuilder,\n    headers?: QueryRequestHeaders\n  ): Promise<QuerySuccess<T>> {\n    // TODO: can we refactor to use a type predicate here instead?\n    if (\"query\" in request) {\n      return this.#query({ ...request, ...headers });\n    }\n    return this.#query(request.toQuery(headers));\n  }\n\n  async #query<T = any>(queryRequest: QueryRequest): Promise<QuerySuccess<T>> {\n    const { query, arguments: args } = queryRequest;\n    try {\n      const url = `${this.clientConfiguration.endpoint.toString()}query/1`;\n      const headers = {\n        Authorization: `Bearer ${this.clientConfiguration.secret}`,\n        \"Content-Type\": \"application/json\",\n      };\n\n      this.#setHeaders(this.clientConfiguration, headers);\n\n      const response = await this.clientConfiguration.fetch<T>(url, {\n        method: \"POST\",\n        headers,\n        body: JSON.stringify({\n          query,\n          arguments: args,\n          // WIP - typecheck should be user configurable, but hard code for now\n          typecheck: false,\n          // WIP - presently core will default to tagged; hardcode to simple for now\n          // until we get back to work on the JS driver.\n          format: \"simple\",\n        }),\n        keepalive: true,\n      });\n\n      const queryResult = response.body;\n\n      if (queryResponseIsFailure(queryResult)) {\n        throw this.#getServiceError(response.status, queryResult);\n      }\n\n      const txn_time = queryResult.txn_time;\n      const txnDate = new Date(txn_time);\n      if (\n        (this.#lastTxn === undefined && txn_time !== undefined) ||\n        (txn_time !== undefined &&\n          this.#lastTxn !== undefined &&\n          this.#lastTxn < txnDate)\n      ) {\n        this.#lastTxn = txnDate;\n      }\n\n      return queryResult;\n    } catch (e: any) {\n      if (e instanceof ServiceError) {\n        throw e;\n      }\n      throw this.#getError(e);\n    }\n  }\n\n  #getError(e: any): ServiceError | ProtocolError | NetworkError | ClientError {\n    // see: https://axios-http.com/docs/handling_errors\n    if (e.response) {\n      // we got an error from the fauna service\n      if (e.response.data?.error) {\n        const error = e.response.data.error;\n        // WIP - summary is moving to a top-level field in the service\n        if (\n          error.summary === undefined &&\n          e.response.data.summary !== undefined\n        ) {\n          error.summary = e.response.data.summary;\n        }\n        return this.#getServiceError(error, e.response.status);\n      }\n      // we got a different error from the protocol layer\n      return new ProtocolError({\n        message: e.message,\n        httpStatus: e.response.status,\n      });\n    }\n    // we're in the browser dealing with an XMLHttpRequest that was never sent\n    // OR we're in node dealing with an HTTPClient.Request that never connected\n    // OR node or axios hit a network connection problem at a lower level,\n    // OR axios threw a network error\n    // see: https://nodejs.org/api/errors.html#nodejs-error-codes\n    if (\n      e.request?.status === 0 ||\n      e.request?.socket?.connecting ||\n      nodeOrAxiosNetworkErrorCodes.includes(e.code) ||\n      \"Network Error\" === e.message\n    ) {\n      return new NetworkError(\"The network connection encountered a problem.\", {\n        cause: e,\n      });\n    }\n    // unknown error\n    return new ClientError(\n      \"A client level error occurred. Fauna was not called.\",\n      {\n        cause: e,\n      }\n    );\n  }\n\n  #getServiceError(\n    // error: {\n    //   code: string;\n    //   message: string;\n    //   summary?: string;\n    //   stats?: { [key: string]: number };\n    //   trace?: Array<Span>;\n    //   txn_time?: string;\n    // },\n    httpStatus: number,\n    failure: QueryFailure\n  ): ServiceError {\n    if (httpStatus === 401) {\n      return new AuthenticationError(httpStatus, failure);\n    }\n    if (httpStatus === 403) {\n      return new AuthorizationError(httpStatus, failure);\n    }\n    if (httpStatus === 500) {\n      return new ServiceInternalError(httpStatus, failure);\n    }\n    if (httpStatus === 503) {\n      return new ServiceTimeoutError(httpStatus, failure);\n    }\n    if (httpStatus === 429) {\n      return new ThrottlingError(httpStatus, failure);\n    }\n    if (httpStatus === 440) {\n      // TODO stats not yet returned. Include it when it is.\n      return new QueryTimeoutError(httpStatus, failure);\n    }\n    // TODO using a list of codes to categorize as QueryCheckError\n    // vs QueryRutimeError is brittle and coupled to the service\n    // implementation.\n    // We need a field sent across the wire that categorizes 400s as either\n    // runtime failures or check failures so we are not coupled to the list\n    // of codes emitted by the service.\n    if (\n      httpStatus === 400 &&\n      queryCheckFailureCodes.includes(failure.error.code)\n    ) {\n      return new QueryCheckError(httpStatus, failure);\n    } else if (httpStatus === 400) {\n      return new QueryRuntimeError(httpStatus, failure);\n    }\n    return new ServiceError(httpStatus, failure);\n  }\n\n  #setHeaders(fromObject: QueryRequestHeaders, headerObject: any): void {\n    for (const entry of Object.entries(fromObject)) {\n      if (\n        [\n          \"last_txn\",\n          \"timeout_ms\",\n          \"linearized\",\n          \"max_contention_retries\",\n          \"traceparent\",\n          \"tags\",\n        ].includes(entry[0])\n      ) {\n        let headerValue: string;\n        let headerKey = `x-${entry[0].replaceAll(\"_\", \"-\")}`;\n        if (\"tags\" === entry[0]) {\n          headerKey = \"x-fauna-tags\";\n          headerValue = Object.entries(entry[1])\n            .map((tag) => tag.join(\"=\"))\n            .join(\",\");\n        } else {\n          if (typeof entry[1] === \"string\") {\n            headerValue = entry[1];\n          } else {\n            headerValue = String(entry[1]);\n          }\n        }\n        if (\"traceparent\" === entry[0]) {\n          headerKey = entry[0];\n        }\n        headerObject[headerKey] = headerValue;\n      }\n    }\n    if (\n      headerObject[\"x-last-txn\"] === undefined &&\n      this.#lastTxn !== undefined\n    ) {\n      headerObject[\"x-last-txn\"] = this.#lastTxn.toISOString();\n    }\n  }\n}\n\n// Private types and constants for internal logic.\n\nconst queryCheckFailureCodes = [\n  \"invalid_function_definition\",\n  \"invalid_identifier\",\n  \"invalid_query\",\n  \"invalid_syntax\",\n  \"invalid_type\",\n];\n\nconst nodeOrAxiosNetworkErrorCodes = [\n  \"ECONNABORTED\",\n  \"ECONNREFUSED\",\n  \"ECONNRESET\",\n  \"ERR_NETWORK\",\n  \"ETIMEDOUT\",\n  // axios does not yet support http2, but preparing\n  // in case we move to a library that does or axios\n  // adds in support.\n  \"ERR_HTTP_REQUEST_TIMEOUT\",\n  \"ERR_HTTP2_GOAWAY_SESSION\",\n  \"ERR_HTTP2_INVALID_SESSION\",\n  \"ERR_HTTP2_INVALID_STREAM\",\n  \"ERR_HTTP2_OUT_OF_STREAMS\",\n  \"ERR_HTTP2_SESSION_ERROR\",\n  \"ERR_HTTP2_STREAM_CANCEL\",\n  \"ERR_HTTP2_STREAM_ERROR\",\n];\n", "import type {\n  JSONValue,\n  QueryRequest,\n  QueryRequestHeaders,\n} from \"./wire-protocol\";\n\nexport interface QueryBuilder {\n  toQuery: (\n    headers?: QueryRequestHeaders,\n    intialArgNumber?: number\n  ) => QueryRequest;\n}\n\n/**\n * Creates a new QueryBuilder. Accepts template literal inputs.\n * @param queryFragments - a {@link TemplateStringsArray} that constitute\n *   the strings that are the basis of the query.\n * @param queryArgs - an Array\\<JSONValue | QueryBuilder\\> that\n *   constitute the arguments to inject between the queryFragments.\n * @throws Error - if you call this method directly (not using template\n *   literals) and pass invalid construction parameters\n * @example\n * ```typescript\n *  const str = \"baz\";\n *  const num = 17;\n *  const innerQueryBuilder = fql`Math.add(${num}, 3)`;\n *  const queryRequestBuilder = fql`${str}.length == ${innerQueryBuilder}`;\n * ```\n */\nexport function fql(\n  queryFragments: TemplateStringsArray,\n  ...queryArgs: (JSONValue | QueryBuilder)[]\n): QueryBuilder {\n  return QueryBuilderImpl.create(queryFragments, ...queryArgs);\n}\n\n/**\n * Internal class.\n * A builder for composing queries and QueryRequests.\n */\nclass QueryBuilderImpl implements QueryBuilder {\n  readonly #queryInterpolation: QueryInterpolation;\n\n  private constructor(queryInterpolation: QueryInterpolation) {\n    if (\"queryFragments\" in queryInterpolation) {\n      if (\n        queryInterpolation.queryFragments.length === 0 ||\n        queryInterpolation.queryFragments.length !==\n          queryInterpolation.queryArgs.length + 1\n      ) {\n        throw new Error(\"invalid query constructed\");\n      }\n      this.#queryInterpolation = {\n        ...queryInterpolation,\n        queryArgs: QueryBuilderImpl.#buildersFromArgs(\n          queryInterpolation.queryArgs\n        ),\n      };\n    } else {\n      this.#queryInterpolation = queryInterpolation;\n    }\n  }\n\n  /**\n   * Creates a new QueryBuilderImpl. Accepts template literal inputs.\n   * @param queryFragments - a {@link TemplateStringsArray} that constitute\n   *   the strings that are the basis of the query.\n   * @param queryArgs - an Array\\<JSONValue | QueryBuilderImpl\\> that\n   *   constitute the arguments to inject between the queryFragments.\n   * @throws Error - if you call this method directly (not using template\n   *   literals) and pass invalid construction parameters\n   * @example\n   * ```typescript\n   *  const str = \"baz\";\n   *  const num = 17;\n   *  const innerQueryBuilderImpl = QueryBuilderImpl.create`Math.add(${num}, 3)`;\n   *  const queryRequestBuilder = QueryBuilderImpl.create`${str}.length == ${innerQueryBuilderImpl}`;\n   * ```\n   */\n  static create(\n    queryFragments: TemplateStringsArray,\n    ...queryArgs: (JSONValue | QueryBuilder)[]\n  ) {\n    return new QueryBuilderImpl({\n      queryFragments,\n      queryArgs: QueryBuilderImpl.#buildersFromArgs(queryArgs),\n    });\n  }\n\n  /**\n   * Converts this QueryBuilderImpl to a {@link QueryRequest} you can send\n   * to Fauna.\n   * @param requestHeaders - optional {@link QueryRequestHeaders} to include\n   *   in the request (and thus override the defaults in your {@link ClientConfiguration}.\n   *   If not passed in, no headers will be set as overrides.\n   * @param initialArgNumber - optional number to start the argument names\n   *   with. Defaults to zero.\n   * @returns a {@link QueryRequest}.\n   * @example\n   * ```typescript\n   *  const str = \"baz\";\n   *  const num = 17;\n   *  const innerQueryBuilder = fql`Math.add(${num}, 3)`;\n   *  const queryRequestBuilder = fql`${str}.length == ${innerQueryBuilder}`;\n   *  const queryRequest: QueryRequest = queryRequestBuilder.toQuery();\n   *  // produces:\n   *  { query: \"arg0.length == Math.add(arg1, 3)\", arguments: { arg0: \"baz\", arg1: 17 }}\n   * ```\n   */\n  toQuery(\n    requestHeaders: QueryRequestHeaders = {},\n    initialArgNumber = 0\n  ): QueryRequest {\n    return { ...this.#render(initialArgNumber), ...requestHeaders };\n  }\n\n  static #buildersFromArgs(\n    queryArgs: (JSONValue | QueryBuilder)[]\n  ): QueryBuilder[] {\n    return queryArgs.map((queryArg) => {\n      if (typeof (<QueryBuilder>queryArg)?.toQuery === \"function\") {\n        return <QueryBuilder>queryArg;\n      }\n      return new QueryBuilderImpl({ json: <JSONValue>queryArg });\n    });\n  }\n\n  #render(nextArg = 0) {\n    if (\"queryFragments\" in this.#queryInterpolation) {\n      const { queryFragments, queryArgs: localArgs } = this.#queryInterpolation;\n      const queryFragment = queryFragments[0];\n      if (queryFragment === undefined) {\n        throw new Error(\"Internal error!\");\n      }\n      const renderedQuery: string[] = [queryFragment];\n      let args: Record<string, JSONValue> = {};\n      localArgs.forEach((arg, i) => {\n        const { query: argQuery, arguments: argArguments } = arg.toQuery(\n          {},\n          nextArg\n        );\n        if (argArguments !== undefined) {\n          nextArg += Object.keys(argArguments).length;\n        }\n        const queryFragment = queryFragments[i + 1];\n        if (queryFragment === undefined) {\n          throw new Error(\"Internal error!\");\n        }\n        renderedQuery.push(argQuery, queryFragment);\n        args = { ...args, ...argArguments };\n      });\n      return { query: renderedQuery.join(\"\"), arguments: args };\n    } else {\n      const argName = `arg${nextArg}`;\n      const args: { [x: string]: any } = {};\n      args[argName] = this.#queryInterpolation.json;\n      return {\n        query: `${argName}`,\n        arguments: args,\n      };\n    }\n  }\n}\n\n/**\n * A query that can be interpolated.\n * It can be composed of either a set of queryFragments and\n * queryArgs or a plain JSONValue.\n * Note that queryFragments and queryArgs are a javascript\n * artifact that support {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals | template literals}.\n */\ntype QueryInterpolation =\n  | {\n      queryFragments: TemplateStringsArray;\n      queryArgs: QueryBuilder[];\n    }\n  | {\n      json: JSONValue;\n    };\n"],
  "mappings": "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",
  "names": ["queryFragment"]
}
