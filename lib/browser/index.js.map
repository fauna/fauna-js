{
  "version": 3,
  "sources": ["../../src/client-configuration.ts", "../../src/wire-protocol.ts", "../../src/http-client/fetch-client.ts", "../../src/http-client/index.ts", "../../src/tagged-type.ts", "../../src/client.ts", "../../src/query-builder.ts"],
  "sourcesContent": ["import { ValueFormat } from \"./wire-protocol\";\n\n/**\n * Configuration for a client.\n */\nexport interface ClientConfiguration {\n  /**\n   * The {@link URL} of Fauna to call. See {@link endpoints} for some default options.\n   */\n  endpoint: URL;\n  /**\n   * Determines the encoded format expected for the query `arguments` field, and\n   * the `data` field of a successful response.\n   * @remarks **Note, it is very unlikely you need to change this value from its default.**\n   * By default the driver transmits type information over the wire. Fauna also assumes type information is\n   * transmitted by default and thus leaving this value undefined will allow Fauna and the driver to send and\n   * receive type data.\n   *  Type information allows the driver and Fauna to distinguish between types such as int\" and \"long\" which do not\n   * have a standard way of distinguishing in JSON.\n   * Since Fauna assumes typed information is transmitted by default, clients can leave this value undefined to make\n   * full usage of Fauna's primitive types.\n   * You can also explicitly set this to \"tagged\" to get the typing data sent.\n   * Rare use cases can also deal with standard JSON by setting the value to \"simple\". Not that the types\n   * enocodable in standard JSON are a subset of the types encodable in the default \"tagged\" format.\n   * It is not recommended that users use the \"simple\" format as you will lose the typing of your data. e.g. a \"Date\"\n   * will no longer be recognized by the Fauna as a \"Date\", but will instead be treated as a string.\n   */\n  format?: ValueFormat;\n  /**\n   * The maximum number of connections to a make to Fauna.\n   */\n  max_conns: number;\n  /**\n   * A secret for your Fauna DB, used to authorize your queries.\n   * @see https://docs.fauna.com/fauna/current/security/keys\n   */\n  secret: string;\n  /**\n   * The timeout of each query, in milliseconds. This controls the maximum amount of\n   * time Fauna will execute your query before marking it failed.\n   */\n  timeout_ms: number;\n  /**\n   * If true, unconditionally run the query as strictly serialized.\n   * This affects read-only transactions. Transactions which write\n   * will always be strictly serialized.\n   */\n  linearized?: boolean;\n  /**\n   * The max number of times to retry the query if contention is encountered.\n   */\n  max_contention_retries?: number;\n\n  /**\n   * Tags provided back via logging and telemetry.\n   */\n  tags?: { [key: string]: string };\n  /**\n   * A traceparent provided back via logging and telemetry.\n   * Must match format: https://www.w3.org/TR/trace-context/#traceparent-header\n   */\n  traceparent?: string;\n}\n\n/**\n * An extensible interface for a set of Fauna endpoints.\n * @remarks Leverage the `[key: string]: URL;` field to extend to other endpoints.\n */\nexport interface Endpoints {\n  /** Fauna's cloud endpoint. */\n  cloud: URL;\n  /** Fauna's preview endpoint for testing new features - requires beta access. */\n  preview: URL;\n  /**\n   * An endpoint for interacting with local instance of Fauna (e.g. one running in a local docker container).\n   */\n  local: URL;\n  /**\n   * An alias for local.\n   */\n  localhost: URL;\n  /**\n   * Any other endpoint you want your client to support. For example, if you run all requests through a proxy\n   * configure it here. Most clients will not need to leverage this ability.\n   */\n  [key: string]: URL;\n}\n\n/**\n * A extensible set of endpoints for calling Fauna.\n * @remarks Most clients will will not need to extend this set.\n * @example\n * ## To Extend\n * ```typescript\n *   // add to the endpoints constant\n *   endpoints.myProxyEndpoint = new URL(\"https://my.proxy.url\");\n * ```\n */\nexport const endpoints: Endpoints = {\n  cloud: new URL(\"https://db.fauna.com\"),\n  preview: new URL(\"https://db.fauna-preview.com\"),\n  local: new URL(\"http://localhost:8443\"),\n  localhost: new URL(\"http://localhost:8443\"),\n};\n", "/**\n * A request to make to Fauna.\n */\nexport interface QueryRequest extends QueryRequestHeaders {\n  /** The query. */\n  query: string;\n\n  /** Optional arguments if your query is interpolated. */\n  arguments?: JSONObject;\n}\n\nexport interface QueryRequestHeaders {\n  /**\n   * Determines the encoded format expected for the query `arguments` field, and\n   * the `data` field of a successful response.\n   */\n  format?: ValueFormat;\n  /**\n   * The ISO-8601 timestamp of the last transaction the client has previously observed.\n   * This client will track this by default, however, if you wish to override\n   * this value for a given request set this value.\n   */\n  last_txn?: string;\n  /**\n   * If true, unconditionally run the query as strictly serialized.\n   * This affects read-only transactions. Transactions which write\n   * will always be strictly serialized.\n   * Overrides the optional setting for the client.\n   */\n  linearized?: boolean;\n  /**\n   * The timeout to use in this query in milliseconds.\n   * Overrides the timeout for the client.\n   */\n  timeout_ms?: number;\n  /**\n   * The max number of times to retry the query if contention is encountered.\n   * Overrides the optional setting for the client.\n   */\n  max_contention_retries?: number;\n\n  /**\n   * Tags provided back via logging and telemetry.\n   * Overrides the optional setting on the client.\n   */\n  tags?: { [key: string]: string };\n  /**\n   * A traceparent provided back via logging and telemetry.\n   * Must match format: https://www.w3.org/TR/trace-context/#traceparent-header\n   * Overrides the optional setting for the client.\n   */\n  traceparent?: string;\n}\n\nexport type ValueFormat = \"simple\" | \"tagged\"\n\nexport type QueryStats = {\n  /** The amount of Transactional Compute Ops consumed by the query. */\n  compute_ops: number;\n  /** The amount of Transactional Read Ops consumed by the query. */\n  read_ops: number;\n  /** The amount of Transactional Write Ops consumed by the query. */\n  write_ops: number;\n  /** The query run time in milliseconds. */\n  query_time_ms: number;\n  /** The amount of data read from storage, in bytes. */\n  storage_bytes_read: number;\n  /** The amount of data written to storage, in bytes. */\n  storage_bytes_written: number;\n  /** The number of times the transaction was retried due to write contention. */\n  contention_retries: number;\n};\n\nexport type QueryInfo = {\n  /** The last transaction time of the query. An ISO-8601 date string. */\n  txn_time: string;\n  /** A readable summary of any warnings or logs emitted by the query. */\n  summary?: string;\n  /** The value of the x-query-tags header, if it was provided. */\n  query_tags: Record<string, string>;\n  /** Stats on query performance and cost */\n  stats: QueryStats;\n};\n\nexport type QuerySuccess<T> = QueryInfo & {\n  /**\n   * The result of the query. The data is any valid JSON value.\n   * @remarks\n   * data is type parameterized so that you can treat it as a\n   * certain type if you are using typescript.\n   */\n  data: T;\n  /** The query's inferred static result type. */\n  static_type?: string;\n};\n\n/**\n * A failed query response. Integrations which only want to report a human\n * readable version of the failure can simply print out the \"summary\" field.\n */\nexport type QueryFailure = QueryInfo & {\n  /**\n   * The result of the query resulting in\n   */\n  error: {\n    /** A predefined code which indicates the type of error. See XXX for a list of error codes. */\n    code: string;\n    /** description: A short, human readable description of the error */\n    message: string;\n  };\n};\n\nexport type QueryResponse<T> = QuerySuccess<T> | QueryFailure;\n\nexport const isQuerySuccess = (res: any): res is QuerySuccess<any> =>\n  res instanceof Object && \"data\" in res;\n\nexport const isQueryFailure = (res: any): res is QueryFailure =>\n  res instanceof Object &&\n  \"error\" in res &&\n  res.error instanceof Object &&\n  \"code\" in res.error &&\n  \"message\" in res.error;\n\nexport const isQueryResponse = (res: any): res is QueryResponse<any> =>\n  isQueryResponse(res) || isQueryFailure(res);\n\n/**\n * An error representing a query failure returned by Fauna.\n */\nexport class ServiceError extends Error {\n  /**\n   * The HTTP Status Code of the error.\n   */\n  readonly httpStatus: number;\n  /**\n   * A code for the error. Codes indicate the cause of the error.\n   * It is safe to write programmatic logic against the code. They are\n   * part of the API contract.\n   */\n  readonly code: string;\n  /**\n   * A summary of the error in a human readable form. Only present\n   * where message does not suffice.\n   */\n  readonly summary?: string;\n\n  constructor(failure: QueryFailure, httpStatus: number) {\n    super(failure.error.message);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ServiceError);\n    }\n\n    this.name = \"ServiceError\";\n    this.code = failure.error.code;\n    this.httpStatus = httpStatus;\n    if (failure.summary) {\n      this.summary = failure.summary;\n    }\n  }\n}\n\n/**\n * An error response that is the result of the query failing during execution.\n * QueryRuntimeError's occur when a bug in your query causes an invalid execution\n * to be requested.\n * The 'code' field will vary based on the specific error cause.\n */\nexport class QueryRuntimeError extends ServiceError {\n  constructor(failure: QueryFailure, httpStatus: 400) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, QueryRuntimeError);\n    }\n    this.name = \"QueryRuntimeError\";\n    // TODO trace, txn_time, and stats not yet returned for QueryRuntimeError\n    // flip to check for those rather than a specific code.\n  }\n}\n\n/**\n * An error due to a \"compile-time\" check of the query\n * failing.\n */\nexport class QueryCheckError extends ServiceError {\n  constructor(failure: QueryFailure, httpStatus: 400) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, QueryCheckError);\n    }\n    this.name = \"QueryCheckError\";\n  }\n}\n\n/**\n * A failure due to the timeout being exceeded, but the timeout\n * was set lower than the query's expected processing time.\n * This response is distinguished from a ServiceTimeoutException\n * in that a QueryTimeoutError shows Fauna behaving in an expected\n * manner.\n */\nexport class QueryTimeoutError extends ServiceError {\n  /**\n   * Statistics regarding the query.\n   */\n  readonly stats?: { [key: string]: number };\n\n  constructor(failure: QueryFailure, httpStatus: 440) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, QueryTimeoutError);\n    }\n    this.name = \"QueryTimeoutError\";\n    this.stats = failure.stats;\n  }\n}\n\n/**\n * AuthenticationError indicates invalid credentials were\n * used.\n */\nexport class AuthenticationError extends ServiceError {\n  constructor(failure: QueryFailure, httpStatus: 401) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AuthenticationError);\n    }\n    this.name = \"AuthenticationError\";\n  }\n}\n\n/**\n * AuthorizationError indicates the credentials used do not have\n * permission to perform the requested action.\n */\nexport class AuthorizationError extends ServiceError {\n  constructor(failure: QueryFailure, httpStatus: 403) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AuthorizationError);\n    }\n    this.name = \"AuthorizationError\";\n  }\n}\n\n/**\n * ThrottlingError indicates some capacity limit was exceeded\n * and thus the request could not be served.\n */\nexport class ThrottlingError extends ServiceError {\n  constructor(failure: QueryFailure, httpStatus: 429) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ThrottlingError);\n    }\n    this.name = \"ThrottlingError\";\n  }\n}\n\n/**\n * ServiceInternalError indicates Fauna failed unexpectedly.\n */\nexport class ServiceInternalError extends ServiceError {\n  constructor(failure: QueryFailure, httpStatus: 500) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ServiceInternalError);\n    }\n    this.name = \"ServiceInternalError\";\n  }\n}\n\n/**\n * ServiceTimeoutError indicates Fauna was not available to servce\n * the request before the timeout was reached.\n */\nexport class ServiceTimeoutError extends ServiceError {\n  constructor(failure: QueryFailure, httpStatus: 503) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ServiceTimeoutError);\n    }\n    this.name = \"ServiceTimeoutError\";\n  }\n}\n\n/**\n * An error representing a failure internal to the client, itself.\n * This indicates Fauna was never called - the client failed internally\n * prior to sending the qreuest.\n */\nexport class ClientError extends Error {\n  constructor(message: string, options: { cause: any }) {\n    super(message, options);\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ClientError);\n    }\n    this.name = \"ClientError\";\n  }\n}\n\n/**\n * An error representing a failure due to the network.\n * This indicates Fauna was never reached.\n */\nexport class NetworkError extends Error {\n  constructor(message: string, options: { cause: any }) {\n    super(message, options);\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, NetworkError);\n    }\n    this.name = \"NetworkError\";\n  }\n}\n\n/**\n * An error representing a HTTP failure - but one not directly\n * emitted by Fauna.\n */\nexport class ProtocolError extends Error {\n  /**\n   * The HTTP Status Code of the error.\n   */\n  readonly httpStatus: number;\n\n  constructor(error: { message: string; httpStatus: number }) {\n    super(error.message);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ProtocolError);\n    }\n\n    this.name = \"ProtocolError\";\n    this.httpStatus = error.httpStatus;\n  }\n}\n\n/**\n * A source span indicating a segment of FQL.\n */\nexport interface Span {\n  /**\n   * A string identifier of the FQL source. For example, if performing\n   * a raw query against the API this would be *query*.\n   */\n  src: string;\n  /**\n   * The span's starting index within the src, inclusive.\n   */\n  start: number;\n  /**\n   * The span's ending index within the src, inclusive.\n   */\n  end: number;\n  /**\n   * The name of the enclosing function, if applicable.\n   */\n  function: string;\n}\n\n/**\n * All objects returned from Fauna are valid JSON objects.\n */\nexport type JSONObject = {\n  [key: string]: JSONValue;\n};\n\n/**\n * All values returned from Fauna are valid JSON values.\n */\nexport type JSONValue =\n  | null\n  | string\n  | number\n  | boolean\n  | JSONObject\n  | Array<JSONValue>;\n", "/** following reference needed to include types for experimental fetch API in Node */\n/// <reference lib=\"dom\" />\n\nimport { NetworkError } from \"../wire-protocol\";\nimport { HTTPClient, HTTPRequest, HTTPResponse } from \"./index\";\n\n/**\n * An implementation for {@link HTTPClient} that uses the native fetch API\n */\nexport class FetchClient implements HTTPClient {\n  /** {@inheritDoc HTTPClient.request} */\n  async request({\n    data,\n    headers: requestHeaders,\n    method,\n    url,\n  }: HTTPRequest): Promise<HTTPResponse> {\n    // TODO: handle client timeouts with AbortController. Emit NetworkError if so.\n\n    const response = await fetch(url, {\n      method,\n      headers: { ...requestHeaders, \"Content-Type\": \"application/json\" },\n      body: JSON.stringify(data),\n    }).catch((error) => {\n      throw new NetworkError(\"The network connection encountered a problem.\", {\n        cause: error,\n      });\n    });\n\n    const status = response.status;\n\n    const responseHeaders: Record<string, string> = {};\n    response.headers.forEach((value, key) => (responseHeaders[key] = value));\n\n    const body = await response.text();\n\n    return {\n      status,\n      body,\n      headers: responseHeaders,\n    };\n  }\n}\n", "import type { Client } from \"../client\";\nimport { QueryRequest } from \"../wire-protocol\";\nimport { FetchClient } from \"./fetch-client\";\nexport { FetchClient } from \"./fetch-client\";\n\n/**\n * An object representing an http request.\n * The {@link Client} provides this to the {@link HTTPClient} implementation.\n */\nexport type HTTPRequest = {\n  data: QueryRequest;\n  headers: Record<string, string>;\n  method: string;\n  url: string;\n};\n\n/**\n * An object representing an http request.\n * It is returned to, and handled by, the {@link Client}.\n */\nexport type HTTPResponse = {\n  body: string;\n  headers: Record<string, string | string[]>;\n  status: number;\n};\n\n/**\n * An interface to provide implementation-specific, asyncronous http calls.\n * This driver provides default implementations for common environments. Users\n * can configure the {@link Client} to use custom implementations if desired.\n */\nexport interface HTTPClient {\n  /**\n   * Makes an HTTP request and returns the response\n   * @param req - an {@link HTTPRequest}\n   * @returns A Promise&lt;{@link HTTPResponse}&gt;\n   */\n  request(req: HTTPRequest): Promise<HTTPResponse>;\n}\n\nexport const getDefaultHTTPClient = () => {\n  // WIP: we only have one implementation right now, but should eventually\n  // inspect the environment for the correct implementation\n  return new FetchClient();\n};\n\n// utility functions\n\nexport const isHTTPResponse = (res: any): res is HTTPResponse =>\n  res instanceof Object && \"body\" in res && \"headers\" in res && \"status\" in res;\n", "/** A reference to a built in Fauna module; e.g. Date */\nexport type Module = string;\n/** A reference to a document in Fauna */\nexport type DocumentReference = string;\n\n/**\n * TaggedType provides the encoding/decoding of the Fauna Tagged Type formatting\n */\nexport class TaggedTypeFormat {\n  /**\n   * Encode the Object to the Tagged Type format for Fauna\n   *\n   * @param obj - Object that will be encoded\n   * @returns Map of result\n   */\n  static encode(obj: any): any {\n    return new TaggedTypeEncoded(obj).result;\n  }\n\n  /**\n   * Decode the JSON string result from Fauna to remove Tagged Type formatting.\n   *\n   * @param input - JSON string result from Fauna\n   * @returns object of result of FQL query\n   */\n  static decode(input: string): any {\n    return JSON.parse(input, (_, value: any) => {\n      if (value == null) return null;\n      if (value[\"@mod\"]) {\n        return value[\"@mod\"] as Module;\n      } else if (value[\"@doc\"]) {\n        return value[\"@doc\"] as DocumentReference;\n      } else if (value[\"@int\"]) {\n        return Number(value[\"@int\"]);\n      } else if (value[\"@long\"]) {\n        return BigInt(value[\"@long\"]);\n      } else if (value[\"@double\"]) {\n        return Number(value[\"@double\"]);\n      } else if (value[\"@date\"]) {\n        return new Date(value[\"@date\"] + \"T00:00:00.000Z\");\n      } else if (value[\"@time\"]) {\n        return new Date(value[\"@time\"]);\n      } else if (value[\"@object\"]) {\n        return value[\"@object\"];\n      }\n\n      return value;\n    });\n  }\n}\n\ntype TaggedDate = { \"@date\": string };\ntype TaggedDouble = { \"@double\": string };\ntype TaggedInt = { \"@int\": string };\ntype TaggedLong = { \"@long\": string };\ntype TaggedObject = { \"@object\": Record<string, any> };\ntype TaggedTime = { \"@time\": string };\n\nexport const LONG_MIN = BigInt(\"-9223372036854775808\");\nexport const LONG_MAX = BigInt(\"9223372036854775807\");\n\nclass TaggedTypeEncoded {\n  readonly result: any;\n\n  readonly #encodeMap = {\n    bigint: (value: bigint): TaggedLong => {\n      if (value < LONG_MIN || value > LONG_MAX) {\n        throw new TypeError(\n          \"Precision loss when converting BigInt to Fauna type\"\n        );\n      }\n\n      return {\n        \"@long\": value.toString(),\n      };\n    },\n    number: (value: number): TaggedDouble | TaggedInt | TaggedLong => {\n      if (\n        value === Number.POSITIVE_INFINITY ||\n        value === Number.NEGATIVE_INFINITY\n      ) {\n        throw new TypeError(`Cannot convert ${value} to a Fauna type`);\n      }\n\n      if (`${value}`.includes(\".\")) {\n        return { \"@double\": value.toString() };\n      } else {\n        if (value >= -(2 ** 31) && value <= 2 ** 31 - 1) {\n          return { \"@int\": value.toString() };\n        } else if (Number.isSafeInteger(value)) {\n          return {\n            \"@long\": value.toString(),\n          };\n        }\n        return { \"@double\": value.toString() };\n      }\n    },\n    string: (value: string): string => {\n      return value;\n    },\n    object: (input: any): TaggedObject | Record<string, any> => {\n      let wrapped = false;\n      const _out: Record<string, any> = {};\n\n      for (const k in input) {\n        if (k.startsWith(\"@\")) {\n          wrapped = true;\n        }\n        _out[k] = TaggedTypeFormat.encode(input[k]);\n      }\n      return wrapped ? { \"@object\": _out } : _out;\n    },\n    array: (input: Array<any>): Array<any> => {\n      const _out: any = [];\n      for (const i in input) _out.push(TaggedTypeFormat.encode(input[i]));\n      return _out;\n    },\n    date: (dateValue: Date): TaggedDate | TaggedTime => {\n      if (\n        dateValue.getUTCHours() == 0 &&\n        dateValue.getUTCMinutes() == 0 &&\n        dateValue.getUTCSeconds() == 0 &&\n        dateValue.getUTCMilliseconds() == 0\n      ) {\n        return { \"@date\": dateValue.toISOString().split(\"T\")[0] };\n      }\n\n      return { \"@time\": dateValue.toISOString() };\n    },\n  };\n\n  constructor(input: any) {\n    // default to encoding directly as the input\n    this.result = input;\n\n    switch (typeof input) {\n      case \"bigint\":\n        this.result = this.#encodeMap[\"bigint\"](input);\n        break;\n      case \"string\":\n        this.result = this.#encodeMap[\"string\"](input);\n        break;\n      case \"number\":\n        this.result = this.#encodeMap[\"number\"](input);\n        break;\n      case \"object\":\n        if (input == null) {\n          this.result = null;\n        } else if (Array.isArray(input)) {\n          this.result = this.#encodeMap[\"array\"](input);\n        } else if (input instanceof Date) {\n          this.result = this.#encodeMap[\"date\"](input);\n        } else {\n          this.result = this.#encodeMap[\"object\"](input);\n        }\n        break;\n    }\n  }\n}\n", "import { ClientConfiguration, endpoints } from \"./client-configuration\";\nimport type { QueryBuilder } from \"./query-builder\";\nimport {\n  AuthenticationError,\n  AuthorizationError,\n  ClientError,\n  isQueryFailure,\n  isQuerySuccess,\n  NetworkError,\n  ProtocolError,\n  QueryCheckError,\n  QueryRuntimeError,\n  QueryTimeoutError,\n  ServiceError,\n  ServiceInternalError,\n  ServiceTimeoutError,\n  ThrottlingError,\n  type QueryFailure,\n  type QueryRequest,\n  type QueryRequestHeaders,\n  type QuerySuccess,\n} from \"./wire-protocol\";\nimport {\n  getDefaultHTTPClient,\n  HTTPResponse,\n  isHTTPResponse,\n  type HTTPClient,\n} from \"./http-client\";\nimport { TaggedTypeFormat } from \"./tagged-type\";\n\nconst defaultClientConfiguration: Pick<\n  ClientConfiguration,\n  \"endpoint\" | \"max_conns\" | \"timeout_ms\"\n> = {\n  endpoint: endpoints.cloud,\n  max_conns: 10,\n  timeout_ms: 60_000,\n};\n\n/**\n * Client for calling Fauna.\n */\nexport class Client {\n  /** The {@link ClientConfiguration} */\n  readonly #clientConfiguration: ClientConfiguration;\n  /** The underlying {@link HTTPClient} client. */\n  readonly #httpClient: HTTPClient;\n  /** last_txn this client has seen */\n  #lastTxn?: Date;\n  /** url of Fauna */\n  #url: string;\n\n  /**\n   * Constructs a new {@link Client}.\n   * @param clientConfiguration - the {@link ClientConfiguration} to apply. Defaults to recommended ClientConfiguraiton.\n   * @param httpClient - The underlying {@link HTTPClient} that will execute the actual HTTP calls. Defaults to recommended HTTPClient.\n   * @example\n   * ```typescript\n   *  const myClient = new Client(\n   *   {\n   *     endpoint: endpoints.cloud,\n   *     max_conns: 10,\n   *     secret: \"foo\",\n   *     timeout_ms: 60_000,\n   *   }\n   * );\n   * ```\n   */\n  constructor(\n    clientConfiguration?: Partial<ClientConfiguration>,\n    httpClient?: HTTPClient\n  ) {\n    this.#clientConfiguration = {\n      ...defaultClientConfiguration,\n      ...clientConfiguration,\n      secret: this.#getSecret(clientConfiguration),\n    };\n    this.#url = `${this.clientConfiguration.endpoint.toString()}query/1`;\n    if (!httpClient) {\n      this.#httpClient = getDefaultHTTPClient();\n    } else {\n      this.#httpClient = httpClient;\n    }\n  }\n\n  /**\n   * @returns the last transaction time seen by this client, or undefined if this client has not seen a transaction time.\n   */\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  get lastTxnTime(): Date | undefined {\n    return this.#lastTxn;\n  }\n  /**\n   * Sets the last transaction time of this client.\n   * @param time - the last transaction time to set.\n   * @throws Error if lastTxnTime is before the current lastTxn of the driver\n   */\n  set lastTxnTime(time: Date) {\n    if (\n      this.lastTxnTime !== undefined &&\n      time.getTime() < this.lastTxnTime.getTime()\n    ) {\n      throw new Error(\"Must be greater than current value\");\n    }\n    this.#lastTxn = time;\n  }\n\n  /**\n   * Return the {@link ClientConfiguration} of this client, save for the secret.\n   */\n  get clientConfiguration(): Omit<ClientConfiguration, \"secret\"> {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const { secret, ...rest } = this.#clientConfiguration;\n    return rest;\n  }\n\n  /**\n   * Queries Fauna.\n   * @param request - a {@link QueryRequest} or {@link QueryBuilder} to build a request with.\n   *  Note, you can embed header fields in this object; if you do that there's no need to\n   *  pass the headers parameter.\n   * @param headers - optional {@link QueryRequestHeaders} to apply on top of the request input.\n   *   Values in this headers parameter take precedence over the same values in the request\n   *   parameter. This field is primarily intended to be used when you pass a QueryBuilder as\n   *   the parameter.\n   * @returns Promise&lt;{@link QuerySuccess}&gt;.\n   * @throws {@link ServiceError} Fauna emitted an error. The ServiceError will be\n   *   one of ServiceError's child classes if the error can be further categorized,\n   *   or a concrete ServiceError if it cannot. ServiceError child types are\n   *   {@link AuthenticaionError}, {@link AuthorizationError}, {@link QueryCheckError}\n   *   {@link QueryRuntimeError}, {@link QueryTimeoutError}, {@link ServiceInternalError}\n   *   {@link ServiceTimeoutError}, {@link ThrottlingError}.\n   *   You can use either the type, or the underlying httpStatus + code to determine\n   *   the root cause.\n   * @throws {@link ProtocolError} the client a HTTP error not sent by Fauna.\n   * @throws {@link NetworkError} the client encountered a network issue\n   * connecting to Fauna.\n   * @throws A {@link ClientError} the client fails to submit the request\n   * due to an internal error.\n   */\n  async query<T = any>(\n    request: QueryRequest | QueryBuilder,\n    headers?: QueryRequestHeaders\n  ): Promise<QuerySuccess<T>> {\n    if (\"query\" in request) {\n      return this.#query({ ...request, ...headers });\n    }\n    return this.#query(request.toQuery(headers));\n  }\n\n  #getError(e: any): ClientError | NetworkError | ProtocolError | ServiceError {\n    // the error was already handled by the driver\n    if (\n      e instanceof ClientError ||\n      e instanceof NetworkError ||\n      e instanceof ProtocolError ||\n      e instanceof ServiceError\n    ) {\n      return e;\n    }\n\n    // the HTTP request succeeded, but there was an error\n    if (isHTTPResponse(e)) {\n      // we got an error from the fauna service\n      if (isQueryFailure(e.body)) {\n        const failure = e.body;\n        const status = e.status;\n        return this.#getServiceError(failure, status);\n      }\n\n      // we got a different error from the protocol layer\n      return new ProtocolError({\n        message: `Response is in an unkown format: ${e.body}`,\n        httpStatus: e.status,\n      });\n    }\n\n    // unknown error\n    return new ClientError(\n      \"A client level error occurred. Fauna was not called.\",\n      {\n        cause: e,\n      }\n    );\n  }\n\n  #getSecret(partialClientConfig?: Partial<ClientConfiguration>): string {\n    let fallback = undefined;\n    if (typeof process === \"object\") {\n      fallback = process.env[\"FAUNA_SECRET\"];\n    }\n    const maybeSecret = partialClientConfig?.secret || fallback;\n    if (maybeSecret === undefined) {\n      throw new Error(\n        \"You must provide a secret to the driver. Set it \\\nin an environmental variable named FAUNA_SECRET or pass it to the Client\\\n constructor.\"\n      );\n    }\n    return maybeSecret;\n  }\n\n  #getServiceError(failure: QueryFailure, httpStatus: number): ServiceError {\n    switch (httpStatus) {\n      case 400:\n        if (\n          httpStatus === 400 &&\n          queryCheckFailureCodes.includes(failure.error.code)\n        ) {\n          return new QueryCheckError(failure, httpStatus);\n        }\n\n        return new QueryRuntimeError(failure, httpStatus);\n      case 401:\n        return new AuthenticationError(failure, httpStatus);\n      case 403:\n        return new AuthorizationError(failure, httpStatus);\n      case 429:\n        return new ThrottlingError(failure, httpStatus);\n      case 440:\n        return new QueryTimeoutError(failure, httpStatus);\n      case 500:\n        return new ServiceInternalError(failure, httpStatus);\n      case 503:\n        return new ServiceTimeoutError(failure, httpStatus);\n      default:\n        return new ServiceError(failure, httpStatus);\n    }\n  }\n\n  async #query<T = any>(queryRequest: QueryRequest): Promise<QuerySuccess<T>> {\n    try {\n      const headers = {\n        Authorization: `Bearer ${this.#clientConfiguration.secret}`,\n        // WIP - typecheck should be user configurable, but hard code for now\n        \"x-typecheck\": \"false\",\n      };\n      this.#setHeaders(\n        { ...this.clientConfiguration, ...queryRequest },\n        headers\n      );\n\n      const isTaggedFormat =\n        (this.#clientConfiguration.format ?? \"tagged\") === \"tagged\" ||\n        queryRequest.format === \"tagged\";\n      const queryArgs = isTaggedFormat\n        ? TaggedTypeFormat.encode(queryRequest.arguments)\n        : queryRequest.arguments;\n\n      const requestData = {\n        query: queryRequest.query,\n        arguments: queryArgs,\n      };\n\n      const fetchResponse = await this.#httpClient.request({\n        url: this.#url,\n        method: \"POST\",\n        headers,\n        data: requestData,\n      });\n\n      let parsedResponse: HTTPResponse;\n      try {\n        parsedResponse = {\n          ...fetchResponse,\n          body: isTaggedFormat\n            ? TaggedTypeFormat.decode(fetchResponse.body)\n            : JSON.parse(fetchResponse.body),\n        };\n      } catch (error: unknown) {\n        throw new ProtocolError({\n          message: `Error parsing response as JSON: ${error}`,\n          httpStatus: fetchResponse.status,\n        });\n      }\n\n      // Response is not from Fauna\n      if (!isQuerySuccess(parsedResponse.body)) {\n        throw this.#getError(parsedResponse);\n      }\n\n      const txn_time = parsedResponse.body.txn_time;\n      const txnDate = new Date(txn_time);\n      if (\n        (this.#lastTxn === undefined && txn_time !== undefined) ||\n        (txn_time !== undefined &&\n          this.#lastTxn !== undefined &&\n          this.#lastTxn < txnDate)\n      ) {\n        this.#lastTxn = txnDate;\n      }\n\n      return parsedResponse.body as QuerySuccess<T>;\n    } catch (e: any) {\n      throw this.#getError(e);\n    }\n  }\n\n  #setHeaders(fromObject: QueryRequestHeaders, headerObject: any): void {\n    for (const entry of Object.entries(fromObject)) {\n      if (\n        [\n          \"format\",\n          \"last_txn\",\n          \"timeout_ms\",\n          \"linearized\",\n          \"max_contention_retries\",\n          \"traceparent\",\n          \"tags\",\n        ].includes(entry[0])\n      ) {\n        let headerValue: string;\n        let headerKey = `x-${entry[0].replaceAll(\"_\", \"-\")}`;\n        if (\"tags\" === entry[0]) {\n          headerKey = \"x-fauna-tags\";\n          headerValue = Object.entries(entry[1])\n            .map((tag) => tag.join(\"=\"))\n            .join(\",\");\n        } else {\n          if (typeof entry[1] === \"string\") {\n            headerValue = entry[1];\n          } else {\n            headerValue = String(entry[1]);\n          }\n        }\n        if (\"traceparent\" === entry[0]) {\n          headerKey = entry[0];\n        }\n        headerObject[headerKey] = headerValue;\n      }\n    }\n    if (\n      headerObject[\"x-last-txn\"] === undefined &&\n      this.#lastTxn !== undefined\n    ) {\n      headerObject[\"x-last-txn\"] = this.#lastTxn.toISOString();\n    }\n  }\n}\n\n// Private types and constants for internal logic.\n\nconst queryCheckFailureCodes = [\n  \"invalid_function_definition\",\n  \"invalid_identifier\",\n  \"invalid_query\",\n  \"invalid_syntax\",\n  \"invalid_type\",\n];\n", "import type {\n  JSONValue,\n  QueryRequest,\n  QueryRequestHeaders,\n} from \"./wire-protocol\";\n\nexport interface QueryBuilder {\n  toQuery: (\n    headers?: QueryRequestHeaders,\n    intialArgNumber?: number\n  ) => QueryRequest;\n}\n\n/**\n * Creates a new QueryBuilder. Accepts template literal inputs.\n * @param queryFragments - a {@link TemplateStringsArray} that constitute\n *   the strings that are the basis of the query.\n * @param queryArgs - an Array\\<JSONValue | QueryBuilder\\> that\n *   constitute the arguments to inject between the queryFragments.\n * @throws Error - if you call this method directly (not using template\n *   literals) and pass invalid construction parameters\n * @example\n * ```typescript\n *  const str = \"baz\";\n *  const num = 17;\n *  const innerQueryBuilder = fql`Math.add(${num}, 3)`;\n *  const queryRequestBuilder = fql`${str}.length == ${innerQueryBuilder}`;\n * ```\n */\nexport function fql(\n  queryFragments: TemplateStringsArray,\n  ...queryArgs: (JSONValue | QueryBuilder)[]\n): QueryBuilder {\n  return QueryBuilderImpl.create(queryFragments, ...queryArgs);\n}\n\n/**\n * Internal class.\n * A builder for composing queries and QueryRequests.\n */\nclass QueryBuilderImpl implements QueryBuilder {\n  readonly #queryInterpolation: QueryInterpolation;\n\n  private constructor(queryInterpolation: QueryInterpolation) {\n    if (\"queryFragments\" in queryInterpolation) {\n      if (\n        queryInterpolation.queryFragments.length === 0 ||\n        queryInterpolation.queryFragments.length !==\n          queryInterpolation.queryArgs.length + 1\n      ) {\n        throw new Error(\"invalid query constructed\");\n      }\n      this.#queryInterpolation = {\n        ...queryInterpolation,\n        queryArgs: QueryBuilderImpl.#buildersFromArgs(\n          queryInterpolation.queryArgs\n        ),\n      };\n    } else {\n      this.#queryInterpolation = queryInterpolation;\n    }\n  }\n\n  /**\n   * Creates a new QueryBuilderImpl. Accepts template literal inputs.\n   * @param queryFragments - a {@link TemplateStringsArray} that constitute\n   *   the strings that are the basis of the query.\n   * @param queryArgs - an Array\\<JSONValue | QueryBuilderImpl\\> that\n   *   constitute the arguments to inject between the queryFragments.\n   * @throws Error - if you call this method directly (not using template\n   *   literals) and pass invalid construction parameters\n   * @example\n   * ```typescript\n   *  const str = \"baz\";\n   *  const num = 17;\n   *  const innerQueryBuilderImpl = QueryBuilderImpl.create`Math.add(${num}, 3)`;\n   *  const queryRequestBuilder = QueryBuilderImpl.create`${str}.length == ${innerQueryBuilderImpl}`;\n   * ```\n   */\n  static create(\n    queryFragments: TemplateStringsArray,\n    ...queryArgs: (JSONValue | QueryBuilder)[]\n  ) {\n    return new QueryBuilderImpl({\n      queryFragments,\n      queryArgs: QueryBuilderImpl.#buildersFromArgs(queryArgs),\n    });\n  }\n\n  /**\n   * Converts this QueryBuilderImpl to a {@link QueryRequest} you can send\n   * to Fauna.\n   * @param requestHeaders - optional {@link QueryRequestHeaders} to include\n   *   in the request (and thus override the defaults in your {@link ClientConfiguration}.\n   *   If not passed in, no headers will be set as overrides.\n   * @param initialArgNumber - optional number to start the argument names\n   *   with. Defaults to zero.\n   * @returns a {@link QueryRequest}.\n   * @example\n   * ```typescript\n   *  const str = \"baz\";\n   *  const num = 17;\n   *  const innerQueryBuilder = fql`Math.add(${num}, 3)`;\n   *  const queryRequestBuilder = fql`${str}.length == ${innerQueryBuilder}`;\n   *  const queryRequest: QueryRequest = queryRequestBuilder.toQuery();\n   *  // produces:\n   *  { query: \"arg0.length == Math.add(arg1, 3)\", arguments: { arg0: \"baz\", arg1: 17 }}\n   * ```\n   */\n  toQuery(\n    requestHeaders: QueryRequestHeaders = {},\n    initialArgNumber = 0\n  ): QueryRequest {\n    return { ...this.#render(initialArgNumber), ...requestHeaders };\n  }\n\n  static #buildersFromArgs(\n    queryArgs: (JSONValue | QueryBuilder)[]\n  ): QueryBuilder[] {\n    return queryArgs.map((queryArg) => {\n      if (typeof (<QueryBuilder>queryArg)?.toQuery === \"function\") {\n        return <QueryBuilder>queryArg;\n      }\n      return new QueryBuilderImpl({ json: <JSONValue>queryArg });\n    });\n  }\n\n  #render(nextArg = 0) {\n    if (\"queryFragments\" in this.#queryInterpolation) {\n      const { queryFragments, queryArgs: localArgs } = this.#queryInterpolation;\n      const queryFragment = queryFragments[0];\n      if (queryFragment === undefined) {\n        throw new Error(\"Internal error!\");\n      }\n      const renderedQuery: string[] = [queryFragment];\n      let args: Record<string, JSONValue> = {};\n      localArgs.forEach((arg, i) => {\n        const { query: argQuery, arguments: argArguments } = arg.toQuery(\n          {},\n          nextArg\n        );\n        if (argArguments !== undefined) {\n          nextArg += Object.keys(argArguments).length;\n        }\n        const queryFragment = queryFragments[i + 1];\n        if (queryFragment === undefined) {\n          throw new Error(\"Internal error!\");\n        }\n        renderedQuery.push(argQuery, queryFragment);\n        args = { ...args, ...argArguments };\n      });\n      return { query: renderedQuery.join(\"\"), arguments: args };\n    } else {\n      const argName = `arg${nextArg}`;\n      const args: { [x: string]: any } = {};\n      args[argName] = this.#queryInterpolation.json;\n      return {\n        query: `${argName}`,\n        arguments: args,\n      };\n    }\n  }\n}\n\n/**\n * A query that can be interpolated.\n * It can be composed of either a set of queryFragments and\n * queryArgs or a plain JSONValue.\n * Note that queryFragments and queryArgs are a javascript\n * artifact that support {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals | template literals}.\n */\ntype QueryInterpolation =\n  | {\n      queryFragments: TemplateStringsArray;\n      queryArgs: QueryBuilder[];\n    }\n  | {\n      json: JSONValue;\n    };\n"],
  "mappings": "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",
  "names": ["endpoints", "isQuerySuccess", "res", "isQueryFailure", "ServiceError", "failure", "httpStatus", "QueryRuntimeError", "QueryCheckError", "QueryTimeoutError", "AuthenticationError", "AuthorizationError", "ThrottlingError", "ServiceInternalError", "ServiceTimeoutError", "ClientError", "message", "options", "NetworkError", "ProtocolError", "error", "FetchClient", "data", "requestHeaders", "method", "url", "response", "error", "NetworkError", "status", "responseHeaders", "value", "key", "body", "getDefaultHTTPClient", "FetchClient", "isHTTPResponse", "res", "TaggedTypeFormat", "obj", "TaggedTypeEncoded", "input", "_", "value", "LONG_MIN", "LONG_MAX", "#encodeMap", "wrapped", "_out", "k", "i", "dateValue", "defaultClientConfiguration", "endpoints", "Client", "#clientConfiguration", "#httpClient", "#lastTxn", "#url", "clientConfiguration", "httpClient", "#getSecret", "getDefaultHTTPClient", "time", "secret", "rest", "request", "headers", "#query", "#getError", "ClientError", "NetworkError", "ProtocolError", "ServiceError", "isHTTPResponse", "isQueryFailure", "failure", "status", "#getServiceError", "partialClientConfig", "fallback", "maybeSecret", "httpStatus", "queryCheckFailureCodes", "QueryCheckError", "QueryRuntimeError", "AuthenticationError", "AuthorizationError", "ThrottlingError", "QueryTimeoutError", "ServiceInternalError", "ServiceTimeoutError", "queryRequest", "#setHeaders", "isTaggedFormat", "queryArgs", "TaggedTypeFormat", "requestData", "fetchResponse", "parsedResponse", "error", "isQuerySuccess", "txn_time", "txnDate", "e", "fromObject", "headerObject", "entry", "headerValue", "headerKey", "tag", "fql", "queryFragments", "queryArgs", "QueryBuilderImpl", "_queryInterpolation", "_buildersFromArgs", "buildersFromArgs_fn", "_render", "render_fn", "_QueryBuilderImpl", "queryInterpolation", "__privateAdd", "_a", "__privateSet", "__privateMethod", "requestHeaders", "initialArgNumber", "queryArg", "nextArg", "__privateGet", "localArgs", "queryFragment", "renderedQuery", "args", "arg", "i", "argQuery", "argArguments", "argName"]
}
