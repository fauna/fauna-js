{
  "version": 3,
  "sources": ["../../src/client-configuration.ts", "../../src/wire-protocol.ts", "../../src/http/index.ts", "../../src/client.ts", "../../src/query-builder.ts"],
  "sourcesContent": ["import { FaunaFetch } from \"./http\";\n\n/**\n * Configuration for a client.\n */\nexport interface ClientConfiguration {\n  /**\n   * The {@link URL} of Fauna to call. See {@link endpoints} for some default options.\n   */\n  endpoint: URL;\n  /**\n   * The maximum number of connections to a make to Fauna.\n   */\n  max_conns: number;\n  /**\n   * A secret for your Fauna DB, used to authorize your queries.\n   * @see https://docs.fauna.com/fauna/current/security/keys\n   */\n  secret: string;\n  /**\n   * The timeout of each query, in milliseconds. This controls the maximum amount of\n   * time Fauna will execute your query before marking it failed.\n   */\n  timeout_ms: number;\n  /**\n   * If true, unconditionally run the query as strictly serialized.\n   * This affects read-only transactions. Transactions which write\n   * will always be strictly serialized.\n   */\n  linearized?: boolean;\n  /**\n   * The max number of times to retry the query if contention is encountered.\n   */\n  max_contention_retries?: number;\n\n  /**\n   * Tags provided back via logging and telemetry.\n   */\n  tags?: { [key: string]: string };\n  /**\n   * A traceparent provided back via logging and telemetry.\n   * Must match format: https://www.w3.org/TR/trace-context/#traceparent-header\n   */\n  traceparent?: string;\n\n  /**\n   * Wrapper for the HTTP requests, modeled after the web API. Can be provided by the user.\n   */\n  fetch: FaunaFetch;\n}\n\n/**\n * An extensible interface for a set of Fauna endpoints.\n * @remarks Leverage the `[key: string]: URL;` field to extend to other endpoints.\n */\nexport interface Endpoints {\n  /** Fauna's cloud endpoint. */\n  cloud: URL;\n  /** Fauna's preview endpoint for testing new features - requires beta access. */\n  preview: URL;\n  /**\n   * An endpoint for interacting with local instance of Fauna (e.g. one running in a local docker container).\n   */\n  local: URL;\n  /**\n   * An alias for local.\n   */\n  localhost: URL;\n  /**\n   * Any other endpoint you want your client to support. For example, if you run all requests through a proxy\n   * configure it here. Most clients will not need to leverage this ability.\n   */\n  [key: string]: URL;\n}\n\n/**\n * A extensible set of endpoints for calling Fauna.\n * @remarks Most clients will will not need to extend this set.\n * @example\n * ## To Extend\n * ```typescript\n *   // add to the endpoints constant\n *   endpoints.myProxyEndpoint = new URL(\"https://my.proxy.url\");\n * ```\n */\nexport const endpoints: Endpoints = {\n  cloud: new URL(\"https://db.fauna.com\"),\n  preview: new URL(\"https://db.fauna-preview.com\"),\n  local: new URL(\"http://localhost:8443\"),\n  localhost: new URL(\"http://localhost:8443\"),\n};\n", "/**\n * A request to make to Fauna.\n */\nexport interface QueryRequest extends QueryRequestHeaders {\n  /** The query. */\n  query: string;\n\n  /** Optional arguments if your query is interpolated. */\n  arguments?: JSONObject;\n}\n\nexport interface QueryRequestHeaders {\n  /**\n   * The ISO-8601 timestamp of the last transaction the client has previously observed.\n   * This client will track this by default, however, if you wish to override\n   * this value for a given request set this value.\n   */\n  last_txn?: string;\n  /**\n   * If true, unconditionally run the query as strictly serialized.\n   * This affects read-only transactions. Transactions which write\n   * will always be strictly serialized.\n   * Overrides the optional setting for the client.\n   */\n  linearized?: boolean;\n  /**\n   * The timeout to use in this query in milliseconds.\n   * Overrides the timeout for the client.\n   */\n  timeout_ms?: number;\n  /**\n   * The max number of times to retry the query if contention is encountered.\n   * Overrides the optional setting for the client.\n   */\n  max_contention_retries?: number;\n\n  /**\n   * Tags provided back via logging and telemetry.\n   * Overrides the optional setting on the client.\n   */\n  tags?: { [key: string]: string };\n  /**\n   * A traceparent provided back via logging and telemetry.\n   * Must match format: https://www.w3.org/TR/trace-context/#traceparent-header\n   * Overrides the optional setting for the client.\n   */\n  traceparent?: string;\n}\n\nexport type QueryStats = {\n  /** The amount of Transactional Compute Ops consumed by the query. */\n  compute_ops: number;\n  /** The amount of Transactional Read Ops consumed by the query. */\n  read_ops: number;\n  /** The amount of Transactional Write Ops consumed by the query. */\n  write_ops: number;\n  /** The query run time in milliseconds. */\n  query_time_ms: number;\n  /** The amount of data read from storage, in bytes. */\n  storage_bytes_read: number;\n  /** The amount of data written to storage, in bytes. */\n  storage_bytes_written: number;\n  /** The number of times the transaction was retried due to write contention. */\n  contention_retries: number;\n};\n\nexport type QueryInfo = {\n  /** The last transaction time of the query. An ISO-8601 date string. */\n  txn_time: string;\n  /** A readable summary of any warnings or logs emitted by the query. */\n  summary: string;\n  /** The value of the x-query-tags header, if it was provided. */\n  query_tags?: Record<string, string>;\n  /** Stats on query performance and cost */\n  stats?: QueryStats;\n};\n\nexport type QuerySuccess<T> = QueryInfo & {\n  /**\n   * The result of the query. The data is any valid JSON value.\n   * @remarks\n   * data is type parameterized so that you can treat it as a\n   * certain type if you are using typescript.\n   */\n  data: T;\n  /** The query's inferred static result type. */\n  static_type?: string;\n};\n\n/**\n * A failed query response. Integrations which only want to report a human\n * readable version of the failure can simply print out the \"summary\" field.\n */\nexport type QueryFailure = QueryInfo & {\n  /**\n   * The result of the query resulting in\n   */\n  error: {\n    /** A predefined code which indicates the type of error. See XXX for a list of error codes. */\n    code: string;\n    /** description: A short, human readable description of the error */\n    message: string;\n  };\n};\n\nconst isQueryInfo = (res: any): res is QueryInfo =>\n  res instanceof Object &&\n  \"summary\" in res;\n\nexport const isQuerySuccess = <T>(res: any): res is QuerySuccess<T> =>\n  isQueryInfo(res) && \"data\" in res;\n\nexport const isQueryFailure = (res: any): res is QueryFailure =>\n  isQueryInfo(res) && \"error\" in res;\n\nexport const isQueryResponse = (\n  res: any\n): res is QuerySuccess<any> | QueryFailure =>\n  isQuerySuccess(res) || isQueryFailure(res);\n\n/**\n * Any error handled by this driver.\n */\nexport class FaunaError extends Error {\n  constructor(...args: any[]) {\n    super(...args);\n  }\n}\n\n/**\n * An error representing a query failure returned by Fauna.\n */\nexport class ServiceError extends FaunaError {\n  /**\n   * The HTTP Status Code of the error.\n   */\n  readonly httpStatus: number;\n  /**\n   * A code for the error. Codes indicate the cause of the error.\n   * It is safe to write programmatic logic against the code. They are\n   * part of the API contract.\n   */\n  readonly code: string;\n  /**\n   * A summary of the error in a human readable form. Only present\n   * where message does not suffice.\n   */\n  readonly summary?: string;\n\n  constructor(failure: QueryFailure, httpStatus: number) {\n    super(failure.error.message);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ServiceError);\n    }\n\n    this.name = \"ServiceError\";\n    this.code = failure.error.code;\n    this.httpStatus = httpStatus;\n    if (failure.summary) {\n      this.summary = failure.summary;\n    }\n  }\n}\n\n/**\n * An error response that is the result of the query failing during execution.\n * QueryRuntimeError's occur when a bug in your query causes an invalid execution\n * to be requested.\n * The 'code' field will vary based on the specific error cause.\n */\nexport class QueryRuntimeError extends ServiceError {\n  constructor(failure: QueryFailure, httpStatus: 400) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, QueryRuntimeError);\n    }\n    this.name = \"QueryRuntimeError\";\n    // TODO trace, txn_time, and stats not yet returned for QueryRuntimeError\n    // flip to check for those rather than a specific code.\n  }\n}\n\n/**\n * An error due to a \"compile-time\" check of the query\n * failing.\n */\nexport class QueryCheckError extends ServiceError {\n  constructor(failure: QueryFailure, httpStatus: 400) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, QueryCheckError);\n    }\n    this.name = \"QueryCheckError\";\n  }\n}\n\n/**\n * A failure due to the timeout being exceeded, but the timeout\n * was set lower than the query's expected processing time.\n * This response is distinguished from a ServiceTimeoutException\n * in that a QueryTimeoutError shows Fauna behaving in an expected\n * manner.\n */\nexport class QueryTimeoutError extends ServiceError {\n  /**\n   * Statistics regarding the query.\n   */\n  readonly stats?: { [key: string]: number };\n\n  constructor(failure: QueryFailure, httpStatus: 440) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, QueryTimeoutError);\n    }\n    this.name = \"QueryTimeoutError\";\n    this.stats = failure.stats;\n  }\n}\n\n/**\n * AuthenticationError indicates invalid credentials were\n * used.\n */\nexport class AuthenticationError extends ServiceError {\n  constructor(failure: QueryFailure, httpStatus: 401) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AuthenticationError);\n    }\n    this.name = \"AuthenticationError\";\n  }\n}\n\n/**\n * AuthorizationError indicates the credentials used do not have\n * permission to perform the requested action.\n */\nexport class AuthorizationError extends ServiceError {\n  constructor(failure: QueryFailure, httpStatus: 403) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AuthorizationError);\n    }\n    this.name = \"AuthorizationError\";\n  }\n}\n\n/**\n * ThrottlingError indicates some capacity limit was exceeded\n * and thus the request could not be served.\n */\nexport class ThrottlingError extends ServiceError {\n  constructor(failure: QueryFailure, httpStatus: 429) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ThrottlingError);\n    }\n    this.name = \"ThrottlingError\";\n  }\n}\n\n/**\n * ServiceInternalError indicates Fauna failed unexpectedly.\n */\nexport class ServiceInternalError extends ServiceError {\n  constructor(failure: QueryFailure, httpStatus: 500) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ServiceInternalError);\n    }\n    this.name = \"ServiceInternalError\";\n  }\n}\n\n/**\n * ServiceTimeoutError indicates Fauna was not available to servce\n * the request before the timeout was reached.\n */\nexport class ServiceTimeoutError extends ServiceError {\n  constructor(failure: QueryFailure, httpStatus: 503) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ServiceTimeoutError);\n    }\n    this.name = \"ServiceTimeoutError\";\n  }\n}\n\n/**\n * An error representing a failure internal to the client, itself.\n * This indicates Fauna was never called - the client failed internally\n * prior to sending the qreuest.\n */\nexport class ClientError extends FaunaError {\n  constructor(message: string, options: { cause: any }) {\n    super(message, options);\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ClientError);\n    }\n    this.name = \"ClientError\";\n  }\n}\n\n/**\n * An error representing a failure due to the network.\n * This indicates Fauna was never reached.\n */\nexport class NetworkError extends FaunaError {\n  constructor(message: string, options: { cause: any }) {\n    super(message, options);\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, NetworkError);\n    }\n    this.name = \"NetworkError\";\n  }\n}\n\n/**\n * An error representing a HTTP failure - but one not directly\n * emitted by Fauna.\n */\nexport class ProtocolError extends FaunaError {\n  /**\n   * The HTTP Status Code of the error.\n   */\n  readonly httpStatus: number;\n\n  constructor(message: string, httpStatus: number) {\n    super(message);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ProtocolError);\n    }\n\n    this.name = \"ProtocolError\";\n    this.httpStatus = httpStatus;\n  }\n}\n\n/**\n * A source span indicating a segment of FQL.\n */\nexport interface Span {\n  /**\n   * A string identifier of the FQL source. For example, if performing\n   * a raw query against the API this would be *query*.\n   */\n  src: string;\n  /**\n   * The span's starting index within the src, inclusive.\n   */\n  start: number;\n  /**\n   * The span's ending index within the src, inclusive.\n   */\n  end: number;\n  /**\n   * The name of the enclosing function, if applicable.\n   */\n  function: string;\n}\n\n/**\n * All objects returned from Fauna are valid JSON objects.\n */\nexport type JSONObject = {\n  [key: string]: JSONValue;\n};\n\n/**\n * All values returned from Fauna are valid JSON values.\n */\nexport type JSONValue =\n  | null\n  | string\n  | number\n  | boolean\n  | JSONObject\n  | Array<JSONValue>;\n", "/** following reference needed to include types for experimental fetch API in Node */\n/// <reference lib=\"dom\" />\n\nimport {\n  NetworkError,\n  ProtocolError,\n  QueryFailure,\n  QuerySuccess,\n} from \"../wire-protocol\";\n\nexport type FetchOptions = {\n  body?: string;\n  keepalive?: true;\n  method?: string;\n  headers?: Record<string, string>;\n};\n\nexport type FetchResponse = {\n  // headers: Record<string, string>,\n  status: number;\n  body: unknown;\n};\n\nexport const isFetchResponse = (res: any): res is FetchResponse =>\n  \"status\" in res && \"body\" in res;\n\nexport type FaunaFetch = (\n  resource: string | URL,\n  options: FetchOptions\n) => Promise<FetchResponse>;\n\nexport const DefaultFetch: FaunaFetch = async (\n  resource: string | URL,\n  options: FetchOptions\n): Promise<FetchResponse> => {\n  // TODO: handle client timeouts with AbortController. Emit NetworkError if so.\n\n  const response = await fetch(resource, options)\n    // handle network errors directly\n    .catch((error) => {\n      throw new NetworkError(\"The network connection encountered a problem.\", {\n        cause: error,\n      });\n    });\n\n  const status = response.status;\n\n  // TODO: include headers. typing for Headers.entries not available?\n  // const headers = response.headers\n  // const headersObj = Object.fromEntries(headers.entries())\n\n  const body: QuerySuccess<unknown> | QueryFailure = await response\n    .json()\n    // handle JSON parsing errors directly\n    .catch((error) => {\n      throw new ProtocolError(\n        \"Error parsing response as JSON. Response: \" + JSON.stringify(error),\n        status\n      );\n    });\n\n  return {\n    status,\n    body,\n  };\n};\n", "import { ClientConfiguration, endpoints } from \"./client-configuration\";\nimport type { QueryBuilder } from \"./query-builder\";\nimport {\n  AuthenticationError,\n  AuthorizationError,\n  ClientError,\n  FaunaError,\n  isQueryFailure,\n  isQueryResponse,\n  isQuerySuccess,\n  NetworkError,\n  ProtocolError,\n  QueryCheckError,\n  QueryRuntimeError,\n  QueryTimeoutError,\n  ServiceError,\n  ServiceInternalError,\n  ServiceTimeoutError,\n  ThrottlingError,\n  type QueryFailure,\n  type QueryRequest,\n  type QueryRequestHeaders,\n  type QuerySuccess,\n} from \"./wire-protocol\";\nimport { DefaultFetch, isFetchResponse } from \"./http\";\n\nconst defaultClientConfiguration = {\n  max_conns: 10,\n  endpoint: endpoints.cloud,\n  timeout_ms: 60_000,\n  fetch: DefaultFetch,\n};\n\n/**\n * Client for calling Fauna.\n */\nexport class Client {\n  /** The {@link ClientConfiguration} */\n  readonly clientConfiguration: ClientConfiguration;\n  /** last_txn this client has seen */\n  #lastTxn?: Date;\n\n  /**\n   * Constructs a new {@link Client}.\n   * @param clientConfiguration - the {@link ClientConfiguration} to apply.\n   * @example\n   * ```typescript\n   *  const myClient = new Client(\n   *   {\n   *     endpoint: endpoints.cloud,\n   *     max_conns: 10,\n   *     secret: \"foo\",\n   *     timeout_ms: 60_000,\n   *   }\n   * );\n   * ```\n   */\n  constructor(clientConfiguration?: Partial<ClientConfiguration>) {\n    this.clientConfiguration = {\n      ...defaultClientConfiguration,\n      ...clientConfiguration,\n      secret: this.#getSecret(clientConfiguration),\n    };\n  }\n\n  /**\n   * Queries Fauna.\n   * @param request - a {@link QueryRequest} or {@link QueryBuilder} to build a request with.\n   *  Note, you can embed header fields in this object; if you do that there's no need to\n   *  pass the headers parameter.\n   * @param headers - optional {@link QueryRequestHeaders} to apply on top of the request input.\n   *   Values in this headers parameter take precedence over the same values in the request\n   *   parameter. This field is primarily intended to be used when you pass a QueryBuilder as\n   *   the parameter.\n   * @returns Promise&lt;{@link QuerySuccess}&gt;.\n   * @throws {@link ServiceError} Fauna emitted an error. The ServiceError will be\n   *   one of ServiceError's child classes if the error can be further categorized,\n   *   or a concrete ServiceError if it cannot. ServiceError child types are\n   *   {@link AuthenticationError}, {@link AuthorizationError}, {@link QueryCheckError}\n   *   {@link QueryRuntimeError}, {@link QueryTimeoutError}, {@link ServiceInternalError}\n   *   {@link ServiceTimeoutError}, {@link ThrottlingError}.\n   *   You can use either the type, or the underlying httpStatus + code to determine\n   *   the root cause.\n   * @throws {@link ProtocolError} the client a HTTP error not sent by Fauna.\n   * @throws {@link NetworkError} the client encountered a network issue\n   * connecting to Fauna.\n   * @throws A {@link ClientError} the client fails to submit the request\n   * due to an internal error.\n   */\n  async query<T = any>(\n    request: QueryRequest | QueryBuilder,\n    headers?: QueryRequestHeaders\n  ): Promise<QuerySuccess<T>> {\n    if (\"query\" in request) {\n      return this.#query({ ...request, ...headers });\n    }\n    return this.#query(request.toQuery(headers));\n  }\n\n  #getError(e: any): ServiceError | ProtocolError | NetworkError | ClientError {\n    // a response was received\n    if (isFetchResponse(e)) {\n      const body = e.body;\n      const status = e.status;\n\n      // the response is from Fauna\n      if (isQueryFailure(body)) {\n        return this.#getServiceError(body, status);\n      }\n\n      // the response is not from Fauna\n      throw new ProtocolError(\n        \"Response body is an unknown format: \" + JSON.stringify(body),\n        status\n      );\n    }\n\n    // unknown error\n    return new ClientError(\n      \"A client level error occurred. Fauna was not called.\",\n      {\n        cause: e,\n      }\n    );\n  }\n\n  #getSecret(partialClientConfig?: Partial<ClientConfiguration>): string {\n    let fallback = undefined;\n    if (typeof process === \"object\") {\n      fallback = process.env[\"FAUNA_SECRET\"];\n    }\n    const maybeSecret = partialClientConfig?.secret || fallback;\n    if (maybeSecret === undefined) {\n      throw new Error(\n        \"You must provide a secret to the driver. Set it \\\nin an environmental variable named FAUNA_SECRET or pass it to the Client\\\n constructor.\"\n      );\n    }\n    return maybeSecret;\n  }\n\n  #getServiceError(failure: QueryFailure, httpStatus: number): ServiceError {\n    switch (httpStatus) {\n      case 400:\n        if (\n          httpStatus === 400 &&\n          queryCheckFailureCodes.includes(failure.error.code)\n        ) {\n          return new QueryCheckError(failure, httpStatus);\n        }\n\n        return new QueryRuntimeError(failure, httpStatus);\n      case 401:\n        return new AuthenticationError(failure, httpStatus);\n      case 403:\n        return new AuthorizationError(failure, httpStatus);\n      case 429:\n        return new ThrottlingError(failure, httpStatus);\n      case 440:\n        return new QueryTimeoutError(failure, httpStatus);\n      case 500:\n        return new ServiceInternalError(failure, httpStatus);\n      case 503:\n        return new ServiceTimeoutError(failure, httpStatus);\n      default:\n        return new ServiceError(failure, httpStatus);\n    }\n  }\n\n  async #query<T = any>(queryRequest: QueryRequest): Promise<QuerySuccess<T>> {\n    const { query, arguments: args } = queryRequest;\n    const headers: { [key: string]: string } = {};\n    this.#setHeaders(queryRequest, headers);\n    try {\n      const url = `${this.clientConfiguration.endpoint.toString()}query/1`;\n      const headers = {\n        Authorization: `Bearer ${this.clientConfiguration.secret}`,\n        \"Content-Type\": \"application/json\",\n        // WIP - typecheck should be user configurable, but hard code for now\n        \"x-typecheck\": \"false\",\n        // WIP - presently core will default to tagged; hardcode to simple for now\n        // until we get back to work on the JS driver.\n        \"x-format\": \"simple\",\n      };\n\n      this.#setHeaders(this.clientConfiguration, headers);\n\n      const fetchResponse = await this.clientConfiguration.fetch(url, {\n        method: \"POST\",\n        headers,\n        body: JSON.stringify({\n          query,\n          arguments: args,\n        }),\n        keepalive: true,\n      });\n      \n      const queryResponse = fetchResponse.body;\n\n      // Response came back as a valid error from Fauna\n      if (isQueryFailure(queryResponse) || !isQueryResponse(queryResponse)) {\n        // throw this.#getServiceError(queryResponse, response.status);\n        throw this.#getError(fetchResponse);\n      }\n\n      // Response is not from Fauna\n      if (!isQuerySuccess(queryResponse)) {\n        throw new ProtocolError(\n          \"Unknown response format: \" + JSON.stringify(fetchResponse),\n          fetchResponse.status\n        );\n      }\n\n      const txn_time = queryResponse.txn_time;\n      const txnDate = new Date(txn_time);\n      if (\n        (this.#lastTxn === undefined && txn_time !== undefined) ||\n        (txn_time !== undefined &&\n          this.#lastTxn !== undefined &&\n          this.#lastTxn < txnDate)\n      ) {\n        this.#lastTxn = txnDate;\n      }\n\n      return queryResponse as QuerySuccess<T>;\n    } catch (e: any) {\n      if (e instanceof FaunaError) {\n        throw e;\n      }\n      throw this.#getError(e);\n    }\n  }\n\n  #setHeaders(fromObject: QueryRequestHeaders, headerObject: any): void {\n    for (const entry of Object.entries(fromObject)) {\n      if (\n        [\n          \"last_txn\",\n          \"timeout_ms\",\n          \"linearized\",\n          \"max_contention_retries\",\n          \"traceparent\",\n          \"tags\",\n        ].includes(entry[0])\n      ) {\n        let headerValue: string;\n        let headerKey = `x-${entry[0].replaceAll(\"_\", \"-\")}`;\n        if (\"tags\" === entry[0]) {\n          headerKey = \"x-fauna-tags\";\n          headerValue = Object.entries(entry[1])\n            .map((tag) => tag.join(\"=\"))\n            .join(\",\");\n        } else {\n          if (typeof entry[1] === \"string\") {\n            headerValue = entry[1];\n          } else {\n            headerValue = String(entry[1]);\n          }\n        }\n        if (\"traceparent\" === entry[0]) {\n          headerKey = entry[0];\n        }\n        headerObject[headerKey] = headerValue;\n      }\n    }\n    if (\n      headerObject[\"x-last-txn\"] === undefined &&\n      this.#lastTxn !== undefined\n    ) {\n      headerObject[\"x-last-txn\"] = this.#lastTxn.toISOString();\n    }\n  }\n}\n\n// Private types and constants for internal logic.\n\nconst queryCheckFailureCodes = [\n  \"invalid_function_definition\",\n  \"invalid_identifier\",\n  \"invalid_query\",\n  \"invalid_syntax\",\n  \"invalid_type\",\n];\n", "import type {\n  JSONValue,\n  QueryRequest,\n  QueryRequestHeaders,\n} from \"./wire-protocol\";\n\nexport interface QueryBuilder {\n  toQuery: (\n    headers?: QueryRequestHeaders,\n    intialArgNumber?: number\n  ) => QueryRequest;\n}\n\n/**\n * Creates a new QueryBuilder. Accepts template literal inputs.\n * @param queryFragments - a {@link TemplateStringsArray} that constitute\n *   the strings that are the basis of the query.\n * @param queryArgs - an Array\\<JSONValue | QueryBuilder\\> that\n *   constitute the arguments to inject between the queryFragments.\n * @throws Error - if you call this method directly (not using template\n *   literals) and pass invalid construction parameters\n * @example\n * ```typescript\n *  const str = \"baz\";\n *  const num = 17;\n *  const innerQueryBuilder = fql`Math.add(${num}, 3)`;\n *  const queryRequestBuilder = fql`${str}.length == ${innerQueryBuilder}`;\n * ```\n */\nexport function fql(\n  queryFragments: TemplateStringsArray,\n  ...queryArgs: (JSONValue | QueryBuilder)[]\n): QueryBuilder {\n  return QueryBuilderImpl.create(queryFragments, ...queryArgs);\n}\n\n/**\n * Internal class.\n * A builder for composing queries and QueryRequests.\n */\nclass QueryBuilderImpl implements QueryBuilder {\n  readonly #queryInterpolation: QueryInterpolation;\n\n  private constructor(queryInterpolation: QueryInterpolation) {\n    if (\"queryFragments\" in queryInterpolation) {\n      if (\n        queryInterpolation.queryFragments.length === 0 ||\n        queryInterpolation.queryFragments.length !==\n          queryInterpolation.queryArgs.length + 1\n      ) {\n        throw new Error(\"invalid query constructed\");\n      }\n      this.#queryInterpolation = {\n        ...queryInterpolation,\n        queryArgs: QueryBuilderImpl.#buildersFromArgs(\n          queryInterpolation.queryArgs\n        ),\n      };\n    } else {\n      this.#queryInterpolation = queryInterpolation;\n    }\n  }\n\n  /**\n   * Creates a new QueryBuilderImpl. Accepts template literal inputs.\n   * @param queryFragments - a {@link TemplateStringsArray} that constitute\n   *   the strings that are the basis of the query.\n   * @param queryArgs - an Array\\<JSONValue | QueryBuilderImpl\\> that\n   *   constitute the arguments to inject between the queryFragments.\n   * @throws Error - if you call this method directly (not using template\n   *   literals) and pass invalid construction parameters\n   * @example\n   * ```typescript\n   *  const str = \"baz\";\n   *  const num = 17;\n   *  const innerQueryBuilderImpl = QueryBuilderImpl.create`Math.add(${num}, 3)`;\n   *  const queryRequestBuilder = QueryBuilderImpl.create`${str}.length == ${innerQueryBuilderImpl}`;\n   * ```\n   */\n  static create(\n    queryFragments: TemplateStringsArray,\n    ...queryArgs: (JSONValue | QueryBuilder)[]\n  ) {\n    return new QueryBuilderImpl({\n      queryFragments,\n      queryArgs: QueryBuilderImpl.#buildersFromArgs(queryArgs),\n    });\n  }\n\n  /**\n   * Converts this QueryBuilderImpl to a {@link QueryRequest} you can send\n   * to Fauna.\n   * @param requestHeaders - optional {@link QueryRequestHeaders} to include\n   *   in the request (and thus override the defaults in your {@link ClientConfiguration}.\n   *   If not passed in, no headers will be set as overrides.\n   * @param initialArgNumber - optional number to start the argument names\n   *   with. Defaults to zero.\n   * @returns a {@link QueryRequest}.\n   * @example\n   * ```typescript\n   *  const str = \"baz\";\n   *  const num = 17;\n   *  const innerQueryBuilder = fql`Math.add(${num}, 3)`;\n   *  const queryRequestBuilder = fql`${str}.length == ${innerQueryBuilder}`;\n   *  const queryRequest: QueryRequest = queryRequestBuilder.toQuery();\n   *  // produces:\n   *  { query: \"arg0.length == Math.add(arg1, 3)\", arguments: { arg0: \"baz\", arg1: 17 }}\n   * ```\n   */\n  toQuery(\n    requestHeaders: QueryRequestHeaders = {},\n    initialArgNumber = 0\n  ): QueryRequest {\n    return { ...this.#render(initialArgNumber), ...requestHeaders };\n  }\n\n  static #buildersFromArgs(\n    queryArgs: (JSONValue | QueryBuilder)[]\n  ): QueryBuilder[] {\n    return queryArgs.map((queryArg) => {\n      if (typeof (<QueryBuilder>queryArg)?.toQuery === \"function\") {\n        return <QueryBuilder>queryArg;\n      }\n      return new QueryBuilderImpl({ json: <JSONValue>queryArg });\n    });\n  }\n\n  #render(nextArg = 0) {\n    if (\"queryFragments\" in this.#queryInterpolation) {\n      const { queryFragments, queryArgs: localArgs } = this.#queryInterpolation;\n      const queryFragment = queryFragments[0];\n      if (queryFragment === undefined) {\n        throw new Error(\"Internal error!\");\n      }\n      const renderedQuery: string[] = [queryFragment];\n      let args: Record<string, JSONValue> = {};\n      localArgs.forEach((arg, i) => {\n        const { query: argQuery, arguments: argArguments } = arg.toQuery(\n          {},\n          nextArg\n        );\n        if (argArguments !== undefined) {\n          nextArg += Object.keys(argArguments).length;\n        }\n        const queryFragment = queryFragments[i + 1];\n        if (queryFragment === undefined) {\n          throw new Error(\"Internal error!\");\n        }\n        renderedQuery.push(argQuery, queryFragment);\n        args = { ...args, ...argArguments };\n      });\n      return { query: renderedQuery.join(\"\"), arguments: args };\n    } else {\n      const argName = `arg${nextArg}`;\n      const args: { [x: string]: any } = {};\n      args[argName] = this.#queryInterpolation.json;\n      return {\n        query: `${argName}`,\n        arguments: args,\n      };\n    }\n  }\n}\n\n/**\n * A query that can be interpolated.\n * It can be composed of either a set of queryFragments and\n * queryArgs or a plain JSONValue.\n * Note that queryFragments and queryArgs are a javascript\n * artifact that support {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals | template literals}.\n */\ntype QueryInterpolation =\n  | {\n      queryFragments: TemplateStringsArray;\n      queryArgs: QueryBuilder[];\n    }\n  | {\n      json: JSONValue;\n    };\n"],
  "mappings": "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",
  "names": ["endpoints", "isQueryInfo", "res", "isQuerySuccess", "isQueryFailure", "isQueryResponse", "FaunaError", "args", "ServiceError", "failure", "httpStatus", "QueryRuntimeError", "QueryCheckError", "QueryTimeoutError", "AuthenticationError", "AuthorizationError", "ThrottlingError", "ServiceInternalError", "ServiceTimeoutError", "ClientError", "message", "options", "NetworkError", "ProtocolError", "isFetchResponse", "res", "DefaultFetch", "resource", "options", "response", "error", "NetworkError", "status", "body", "ProtocolError", "defaultClientConfiguration", "endpoints", "DefaultFetch", "Client", "#lastTxn", "clientConfiguration", "#getSecret", "request", "headers", "#query", "#getError", "isFetchResponse", "body", "status", "isQueryFailure", "#getServiceError", "ProtocolError", "ClientError", "partialClientConfig", "fallback", "maybeSecret", "failure", "httpStatus", "queryCheckFailureCodes", "QueryCheckError", "QueryRuntimeError", "AuthenticationError", "AuthorizationError", "ThrottlingError", "QueryTimeoutError", "ServiceInternalError", "ServiceTimeoutError", "ServiceError", "queryRequest", "query", "args", "#setHeaders", "url", "fetchResponse", "queryResponse", "isQueryResponse", "isQuerySuccess", "txn_time", "txnDate", "e", "FaunaError", "fromObject", "headerObject", "entry", "headerValue", "headerKey", "tag", "fql", "queryFragments", "queryArgs", "QueryBuilderImpl", "_queryInterpolation", "_buildersFromArgs", "buildersFromArgs_fn", "_render", "render_fn", "_QueryBuilderImpl", "queryInterpolation", "__privateAdd", "_a", "__privateSet", "__privateMethod", "requestHeaders", "initialArgNumber", "queryArg", "nextArg", "__privateGet", "localArgs", "queryFragment", "renderedQuery", "args", "arg", "i", "argQuery", "argArguments", "argName"]
}
