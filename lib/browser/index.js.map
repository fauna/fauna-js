{
  "version": 3,
  "sources": ["../../src/client-configuration.ts", "../../src/fetch.ts", "../../src/wire-protocol.ts", "../../src/client.ts", "../../src/query-builder.ts"],
  "sourcesContent": ["import type { FaunaFetch } from \"./fetch\";\n\n/**\n * Configuration for a client.\n */\nexport interface ClientConfiguration {\n  /**\n   * The {@link URL} of Fauna to call. See {@link endpoints} for some default options.\n   */\n  endpoint: URL;\n  /**\n   * The maximum number of connections to a make to Fauna.\n   */\n  max_conns: number;\n  /**\n   * A secret for your Fauna DB, used to authorize your queries.\n   * @see https://docs.fauna.com/fauna/current/security/keys\n   */\n  secret: string;\n  /**\n   * The timeout of each query, in milliseconds. This controls the maximum amount of\n   * time Fauna will execute your query before marking it failed.\n   */\n  timeout_ms: number;\n  /**\n   * If true, unconditionally run the query as strictly serialized.\n   * This affects read-only transactions. Transactions which write\n   * will always be strictly serialized.\n   */\n  linearized?: boolean;\n  /**\n   * The max number of times to retry the query if contention is encountered.\n   */\n  max_contention_retries?: number;\n\n  /**\n   * Tags provided back via logging and telemetry.\n   */\n  tags?: { [key: string]: string };\n  /**\n   * A traceparent provided back via logging and telemetry.\n   * Must match format: https://www.w3.org/TR/trace-context/#traceparent-header\n   */\n  traceparent?: string;\n\n  /**\n   * Wrapper for the HTTP requests, modeled after the web API. Can be provided by the user.\n   */\n  fetch: FaunaFetch;\n}\n\n/**\n * An extensible interface for a set of Fauna endpoints.\n * @remarks Leverage the `[key: string]: URL;` field to extend to other endpoints.\n */\nexport interface Endpoints {\n  /** Fauna's cloud endpoint. */\n  cloud: URL;\n  /** Fauna's preview endpoint for testing new features - requires beta access. */\n  preview: URL;\n  /**\n   * An endpoint for interacting with local instance of Fauna (e.g. one running in a local docker container).\n   */\n  local: URL;\n  /**\n   * An alias for local.\n   */\n  localhost: URL;\n  /**\n   * Any other endpoint you want your client to support. For example, if you run all requests through a proxy\n   * configure it here. Most clients will not need to leverage this ability.\n   */\n  [key: string]: URL;\n}\n\n/**\n * A extensible set of endpoints for calling Fauna.\n * @remarks Most clients will will not need to extend this set.\n * @example\n * ## To Extend\n * ```typescript\n *   // add to the endpoints constant\n *   endpoints.myProxyEndpoint = new URL(\"https://my.proxy.url\");\n * ```\n */\nexport const endpoints: Endpoints = {\n  cloud: new URL(\"https://db.fauna.com\"),\n  preview: new URL(\"https://db.fauna-preview.com\"),\n  local: new URL(\"http://localhost:8443\"),\n  localhost: new URL(\"http://localhost:8443\"),\n};\n", "/** following reference needed to include types for experimental fetch API in Node */\n/// <reference lib=\"dom\" />\n\nimport type { QueryFailure, QuerySuccess } from \"./wire-protocol\";\n\nexport type FetchOptions = {\n  body?: string;\n  keepalive?: true;\n  method?: string;\n  headers?: Record<string, string>;\n};\n\nexport type FetchResponse<T> = {\n  // headers: Record<string, string>,\n  status: number;\n  body: QuerySuccess<T> | QueryFailure;\n};\n\nexport type FaunaFetch = <T>(\n  resource: string | URL,\n  options: FetchOptions\n) => Promise<FetchResponse<T>>;\n\nexport const DefaultFetch: FaunaFetch = async <T>(\n  resource: string | URL,\n  options: FetchOptions\n): Promise<FetchResponse<T>> => {\n  const response = await fetch(resource, options);\n  const status = response.status;\n  const body = (await response.json()) as QuerySuccess<T> | QueryFailure;\n\n  // TODO: include headers. typing for Headers.entries not available?\n  // const headers = response.headers\n  // const headersObj = Object.fromEntries(headers.entries())\n\n  return {\n    status,\n    body,\n  };\n};\n", "/**\n * A request to make to Fauna.\n */\nexport interface QueryRequest extends QueryRequestHeaders {\n  /** The query. */\n  query: string;\n\n  /** Optional arguments if your query is interpolated. */\n  arguments?: JSONObject;\n}\n\nexport interface QueryRequestHeaders {\n  /**\n   * The ISO-8601 timestamp of the last transaction the client has previously observed.\n   * This client will track this by default, however, if you wish to override\n   * this value for a given request set this value.\n   */\n  last_txn?: string;\n  /**\n   * If true, unconditionally run the query as strictly serialized.\n   * This affects read-only transactions. Transactions which write\n   * will always be strictly serialized.\n   * Overrides the optional setting for the client.\n   */\n  linearized?: boolean;\n  /**\n   * The timeout to use in this query in milliseconds.\n   * Overrides the timeout for the client.\n   */\n  timeout_ms?: number;\n  /**\n   * The max number of times to retry the query if contention is encountered.\n   * Overrides the optional setting for the client.\n   */\n  max_contention_retries?: number;\n\n  /**\n   * Tags provided back via logging and telemetry.\n   * Overrides the optional setting on the client.\n   */\n  tags?: { [key: string]: string };\n  /**\n   * A traceparent provided back via logging and telemetry.\n   * Must match format: https://www.w3.org/TR/trace-context/#traceparent-header\n   * Overrides the optional setting for the client.\n   */\n  traceparent?: string;\n}\n\nexport type QueryInfo = {\n  /** Stats on query performance and cost */\n  stats: { [key: string]: number };\n  /** The last transaction time of the query. An ISO-8601 date string. */\n  txn_time: string;\n  /** A readable summary of any warnings or logs emitted by the query. */\n  summary?: string;\n  /** The query's inferred static result type. */\n  static_type?: string;\n};\n\nexport type QuerySuccess<T> = QueryInfo & {\n  /**\n   * The result of the query. The data is any valid JSON value.\n   * @remarks\n   * data is type parameterized so that you can treat it as a\n   * certain type if you are using typescript.\n   */\n  data: T;\n};\n\n/**\n * A failed query response. Integrations which only want to report a human\n * readable version of the failure can simply print out the \"summary\" field.\n */\nexport type QueryFailure = QueryInfo & {\n  /**\n   * The result of the query resulting in\n   */\n  error: {\n    /** A predefined code which indicates the type of error. See XXX for a list of error codes. */\n    code: string;\n    /** description: A short, human readable description of the error */\n    message: string;\n  };\n};\n\nexport const queryResponseIsSuccess = <T>(\n  res: QuerySuccess<T> | QueryFailure\n): res is QuerySuccess<T> => \"data\" in res;\n\nexport const queryResponseIsFailure = (\n  res: QuerySuccess<any> | QueryFailure\n): res is QueryFailure => \"error\" in res;\n\n/**\n * An error representing a query failure returned by Fauna.\n */\nexport class ServiceError extends Error {\n  /**\n   * The HTTP Status Code of the error.\n   */\n  readonly httpStatus: number;\n  /**\n   * A code for the error. Codes indicate the cause of the error.\n   * It is safe to write programmatic logic against the code. They are\n   * part of the API contract.\n   */\n  readonly code: string;\n  /**\n   * A summary of the error in a human readable form. Only present\n   * where message does not suffice.\n   */\n  readonly summary?: string;\n\n  constructor(httpStatus: number, failure: QueryFailure) {\n    super(failure.error.message);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ServiceError);\n    }\n\n    this.name = \"ServiceError\";\n    this.code = failure.error.code;\n    this.httpStatus = httpStatus;\n    if (failure.summary) {\n      this.summary = failure.summary;\n    }\n  }\n}\n\n/**\n * An error response that is the result of the query failing during execution.\n * QueryRuntimeError's occur when a bug in your query causes an invalid execution\n * to be requested.\n * The 'code' field will vary based on the specific error cause.\n */\nexport class QueryRuntimeError extends ServiceError {\n  constructor(httpStatus: number, failure: QueryFailure) {\n    super(httpStatus, failure);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, QueryRuntimeError);\n    }\n    this.name = \"QueryRuntimeError\";\n    // TODO trace, txn_time, and stats not yet returned for QueryRuntimeError\n    // flip to check for those rather than a specific code.\n  }\n}\n\n/**\n * An error due to a \"compile-time\" check of the query\n * failing.\n */\nexport class QueryCheckError extends ServiceError {\n  constructor(httpStatus: number, failure: QueryFailure) {\n    super(httpStatus, failure);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, QueryCheckError);\n    }\n    this.name = \"QueryCheckError\";\n  }\n}\n\n/**\n * A failure due to the timeout being exceeded, but the timeout\n * was set lower than the query's expected processing time.\n * This response is distinguished from a ServiceTimeoutException\n * in that a QueryTimeoutError shows Fauna behaving in an expected\n * manner.\n */\nexport class QueryTimeoutError extends ServiceError {\n  /**\n   * Statistics regarding the query.\n   */\n  readonly stats?: { [key: string]: number };\n\n  constructor(httpStatus: number, failure: QueryFailure) {\n    super(httpStatus, failure);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, QueryTimeoutError);\n    }\n    this.name = \"QueryTimeoutError\";\n    this.stats = failure.stats;\n  }\n}\n\n/**\n * AuthenticationError indicates invalid credentials were\n * used.\n */\nexport class AuthenticationError extends ServiceError {\n  constructor(httpStatus: number, failure: QueryFailure) {\n    super(httpStatus, failure);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AuthenticationError);\n    }\n    this.name = \"AuthenticationError\";\n  }\n}\n\n/**\n * AuthorizationError indicates the credentials used do not have\n * permission to perform the requested action.\n */\nexport class AuthorizationError extends ServiceError {\n  constructor(httpStatus: number, failure: QueryFailure) {\n    super(httpStatus, failure);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AuthorizationError);\n    }\n    this.name = \"AuthorizationError\";\n  }\n}\n\n/**\n * ThrottlingError indicates some capacity limit was exceeded\n * and thus the request could not be served.\n */\nexport class ThrottlingError extends ServiceError {\n  constructor(httpStatus: number, failure: QueryFailure) {\n    super(httpStatus, failure);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ThrottlingError);\n    }\n    this.name = \"ThrottlingError\";\n  }\n}\n\n/**\n * ServiceInternalError indicates Fauna failed unexpectedly.\n */\nexport class ServiceInternalError extends ServiceError {\n  constructor(httpStatus: number, failure: QueryFailure) {\n    super(httpStatus, failure);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ServiceInternalError);\n    }\n    this.name = \"ServiceInternalError\";\n  }\n}\n\n/**\n * ServiceTimeoutError indicates Fauna was not available to servce\n * the request before the timeout was reached.\n */\nexport class ServiceTimeoutError extends ServiceError {\n  constructor(httpStatus: number, failure: QueryFailure) {\n    super(httpStatus, failure);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ServiceTimeoutError);\n    }\n    this.name = \"ServiceTimeoutError\";\n  }\n}\n\n/**\n * An error representing a failure internal to the client, itself.\n * This indicates Fauna was never called - the client failed internally\n * prior to sending the qreuest.\n */\nexport class ClientError extends Error {\n  constructor(message: string, options: { cause: any }) {\n    super(message, options);\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ClientError);\n    }\n    this.name = \"ClientError\";\n  }\n}\n\n/**\n * An error representing a failure due to the network.\n * This indicates Fauna was never reached.\n */\nexport class NetworkError extends Error {\n  constructor(message: string, options: { cause: any }) {\n    super(message, options);\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, NetworkError);\n    }\n    this.name = \"NetworkError\";\n  }\n}\n\n/**\n * An error representing a HTTP failure - but one not directly\n * emitted by Fauna.\n */\nexport class ProtocolError extends Error {\n  /**\n   * The HTTP Status Code of the error.\n   */\n  readonly httpStatus: number;\n\n  constructor(error: { message: string; httpStatus: number }) {\n    super(error.message);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ProtocolError);\n    }\n\n    this.name = \"ProtocolError\";\n    this.httpStatus = error.httpStatus;\n  }\n}\n\n/**\n * A source span indicating a segment of FQL.\n */\nexport interface Span {\n  /**\n   * A string identifier of the FQL source. For example, if performing\n   * a raw query against the API this would be *query*.\n   */\n  src: string;\n  /**\n   * The span's starting index within the src, inclusive.\n   */\n  start: number;\n  /**\n   * The span's ending index within the src, inclusive.\n   */\n  end: number;\n  /**\n   * The name of the enclosing function, if applicable.\n   */\n  function: string;\n}\n\n/**\n * All objects returned from Fauna are valid JSON objects.\n */\nexport type JSONObject = {\n  [key: string]: JSONValue;\n};\n\n/**\n * All values returned from Fauna are valid JSON values.\n */\nexport type JSONValue =\n  | null\n  | string\n  | number\n  | boolean\n  | JSONObject\n  | Array<JSONValue>;\n", "import { ClientConfiguration, endpoints } from \"./client-configuration\";\nimport { DefaultFetch } from \"./fetch\";\nimport type { QueryBuilder } from \"./query-builder\";\nimport {\n  AuthenticationError,\n  AuthorizationError,\n  ClientError,\n  NetworkError,\n  ProtocolError,\n  QueryCheckError,\n  QueryRuntimeError,\n  QueryTimeoutError,\n  ServiceError,\n  ServiceInternalError,\n  ServiceTimeoutError,\n  ThrottlingError,\n  type QueryRequest,\n  type QueryRequestHeaders,\n  type QuerySuccess,\n  type QueryFailure,\n  queryResponseIsFailure,\n} from \"./wire-protocol\";\n\nconst defaultClientConfiguration = {\n  max_conns: 10,\n  endpoint: endpoints.cloud,\n  timeout_ms: 60_000,\n  fetch: DefaultFetch,\n};\n\n/**\n * Client for calling Fauna.\n */\nexport class Client {\n  /** The {@link ClientConfiguration} */\n  readonly clientConfiguration: ClientConfiguration;\n  /** last_txn this client has seen */\n  #lastTxn?: Date;\n\n  /**\n   * Constructs a new {@link Client}.\n   * @param clientConfiguration - the {@link ClientConfiguration} to apply.\n   * @example\n   * ```typescript\n   *  const myClient = new Client(\n   *   {\n   *     endpoint: endpoints.cloud,\n   *     max_conns: 10,\n   *     secret: \"foo\",\n   *     timeout_ms: 60_000,\n   *   }\n   * );\n   * ```\n   */\n  constructor(clientConfiguration?: Partial<ClientConfiguration>) {\n    this.clientConfiguration = {\n      ...defaultClientConfiguration,\n      ...clientConfiguration,\n      secret: this.#getSecret(clientConfiguration),\n    };\n  }\n\n  #getSecret(partialClientConfig?: Partial<ClientConfiguration>): string {\n    let fallback = undefined;\n    if (typeof process === \"object\") {\n      fallback = process.env[\"FAUNA_SECRET\"];\n    }\n    const maybeSecret = partialClientConfig?.secret || fallback;\n    if (maybeSecret === undefined) {\n      throw new Error(\n        \"You must provide a secret to the driver. Set it \\\nin an environmental variable named FAUNA_SECRET or pass it to the Client\\\n constructor.\"\n      );\n    }\n    return maybeSecret;\n  }\n\n  /**\n   * Queries Fauna.\n   * @param request - a {@link QueryRequest} or {@link QueryBuilder} to build a request with.\n   *  Note, you can embed header fields in this object; if you do that there's no need to\n   *  pass the headers parameter.\n   * @param headers - optional {@link QueryRequestHeaders} to apply on top of the request input.\n   *   Values in this headers parameter take precedence over the same values in the request\n   *   parameter. This field is primarily intended to be used when you pass a QueryBuilder as\n   *   the parameter.\n   * @returns Promise&lt;{@link QuerySuccess}&gt;.\n   * @throws {@link ServiceError} Fauna emitted an error. The ServiceError will be\n   *   one of ServiceError's child classes if the error can be further categorized,\n   *   or a concrete ServiceError if it cannot. ServiceError child types are\n   *   {@link AuthenticaionError}, {@link AuthorizationError}, {@link QueryCheckError}\n   *   {@link QueryRuntimeError}, {@link QueryTimeoutError}, {@link ServiceInternalError}\n   *   {@link ServiceTimeoutError}, {@link ThrottlingError}.\n   *   You can use either the type, or the underlying httpStatus + code to determine\n   *   the root cause.\n   * @throws {@link ProtocolError} the client a HTTP error not sent by Fauna.\n   * @throws {@link NetworkError} the client encountered a network issue\n   * connecting to Fauna.\n   * @throws A {@link ClientError} the client fails to submit the request\n   * due to an internal error.\n   */\n  async query<T = any>(\n    request: QueryRequest | QueryBuilder,\n    headers?: QueryRequestHeaders\n  ): Promise<QuerySuccess<T>> {\n    // TODO: can we refactor to use a type predicate here instead?\n    if (\"query\" in request) {\n      return this.#query({ ...request, ...headers });\n    }\n    return this.#query(request.toQuery(headers));\n  }\n\n  async #query<T = any>(queryRequest: QueryRequest): Promise<QuerySuccess<T>> {\n    const { query, arguments: args } = queryRequest;\n    try {\n      const url = `${this.clientConfiguration.endpoint.toString()}query/1`\n      const headers = {\n        Authorization: `Bearer ${this.clientConfiguration.secret}`,\n        \"Content-Type\": \"application/json\",\n        // WIP - presently core will default to tagged; hardcode to simple for now\n        // until we get back to work on the JS driver.\n        \"X-Format\": \"simple\",\n      };\n\n      this.#setHeaders(this.clientConfiguration, headers);\n\n      const response = await this.clientConfiguration.fetch<T>(\n        url,\n        {\n          method: \"POST\",\n          headers,\n          body: JSON.stringify({ query, arguments: args }),\n          keepalive: true,\n        }\n      );\n\n      const queryResult = response.body\n\n      if (queryResponseIsFailure(queryResult)) {\n        throw this.#getServiceError(response.status, queryResult);\n      }\n\n      const txn_time = queryResult.txn_time;\n      const txnDate = new Date(txn_time);\n      if (\n        (this.#lastTxn === undefined && txn_time !== undefined) ||\n        (txn_time !== undefined &&\n          this.#lastTxn !== undefined &&\n          this.#lastTxn < txnDate)\n      ) {\n        this.#lastTxn = txnDate;\n      }\n\n      return queryResult;\n    } catch (e: any) {\n      if (e instanceof ServiceError) {\n        throw e\n      }\n      throw this.#getError(e);\n    }\n  }\n\n  #getError(e: any): ServiceError | ProtocolError | NetworkError | ClientError {\n    // see: https://axios-http.com/docs/handling_errors\n    if (e.response) {\n      // we got an error from the fauna service\n      if (e.response.data?.error) {\n        const error = e.response.data.error;\n        // WIP - summary is moving to a top-level field in the service\n        if (\n          error.summary === undefined &&\n          e.response.data.summary !== undefined\n        ) {\n          error.summary = e.response.data.summary;\n        }\n        return this.#getServiceError(error, e.response.status);\n      }\n      // we got a different error from the protocol layer\n      return new ProtocolError({\n        message: e.message,\n        httpStatus: e.response.status,\n      });\n    }\n    // we're in the browser dealing with an XMLHttpRequest that was never sent\n    // OR we're in node dealing with an HTTPClient.Request that never connected\n    // OR node or axios hit a network connection problem at a lower level,\n    // OR axios threw a network error\n    // see: https://nodejs.org/api/errors.html#nodejs-error-codes\n    if (\n      e.request?.status === 0 ||\n      e.request?.socket?.connecting ||\n      nodeOrAxiosNetworkErrorCodes.includes(e.code) ||\n      \"Network Error\" === e.message\n    ) {\n      return new NetworkError(\"The network connection encountered a problem.\", {\n        cause: e,\n      });\n    }\n    // unknown error\n    return new ClientError(\n      \"A client level error occurred. Fauna was not called.\",\n      {\n        cause: e,\n      }\n    );\n  }\n\n  #getServiceError(\n    // error: {\n    //   code: string;\n    //   message: string;\n    //   summary?: string;\n    //   stats?: { [key: string]: number };\n    //   trace?: Array<Span>;\n    //   txn_time?: string;\n    // },\n    httpStatus: number,\n    failure: QueryFailure\n  ): ServiceError {\n    if (httpStatus === 401) {\n      return new AuthenticationError(httpStatus, failure);\n    }\n    if (httpStatus === 403) {\n      return new AuthorizationError(httpStatus, failure);\n    }\n    if (httpStatus === 500) {\n      return new ServiceInternalError(httpStatus, failure);\n    }\n    if (httpStatus === 503) {\n      return new ServiceTimeoutError(httpStatus, failure);\n    }\n    if (httpStatus === 429) {\n      return new ThrottlingError(httpStatus, failure);\n    }\n    if (httpStatus === 440) {\n      // TODO stats not yet returned. Include it when it is.\n      return new QueryTimeoutError(httpStatus, failure);\n    }\n    // TODO using a list of codes to categorize as QueryCheckError\n    // vs QueryRutimeError is brittle and coupled to the service\n    // implementation.\n    // We need a field sent across the wire that categorizes 400s as either\n    // runtime failures or check failures so we are not coupled to the list\n    // of codes emitted by the service.\n    if (httpStatus === 400 && queryCheckFailureCodes.includes(failure.error.code)) {\n      return new QueryCheckError(httpStatus, failure);\n    } else if (httpStatus === 400) {\n      return new QueryRuntimeError(httpStatus, failure);\n    }\n    return new ServiceError(httpStatus, failure);\n  }\n\n  #setHeaders(fromObject: QueryRequestHeaders, headerObject: any): void {\n    for (const entry of Object.entries(fromObject)) {\n      if (\n        [\n          \"last_txn\",\n          \"timeout_ms\",\n          \"linearized\",\n          \"max_contention_retries\",\n          \"traceparent\",\n          \"tags\",\n        ].includes(entry[0])\n      ) {\n        let headerValue: string;\n        let headerKey = `x-${entry[0].replaceAll(\"_\", \"-\")}`;\n        if (\"tags\" === entry[0]) {\n          headerKey = \"x-fauna-tags\";\n          headerValue = Object.entries(entry[1])\n            .map((tag) => tag.join(\"=\"))\n            .join(\",\");\n        } else {\n          if (typeof entry[1] === \"string\") {\n            headerValue = entry[1];\n          } else {\n            headerValue = String(entry[1]);\n          }\n        }\n        if (\"traceparent\" === entry[0]) {\n          headerKey = entry[0];\n        }\n        headerObject[headerKey] = headerValue;\n      }\n    }\n    if (\n      headerObject[\"x-last-txn\"] === undefined &&\n      this.#lastTxn !== undefined\n    ) {\n      headerObject[\"x-last-txn\"] = this.#lastTxn.toISOString();\n    }\n  }\n}\n\n// Private types and constants for internal logic.\n\nconst queryCheckFailureCodes = [\n  \"invalid_function_definition\",\n  \"invalid_identifier\",\n  \"invalid_query\",\n  \"invalid_syntax\",\n  \"invalid_type\",\n];\n\nconst nodeOrAxiosNetworkErrorCodes = [\n  \"ECONNABORTED\",\n  \"ECONNREFUSED\",\n  \"ECONNRESET\",\n  \"ERR_NETWORK\",\n  \"ETIMEDOUT\",\n  // axios does not yet support http2, but preparing\n  // in case we move to a library that does or axios\n  // adds in support.\n  \"ERR_HTTP_REQUEST_TIMEOUT\",\n  \"ERR_HTTP2_GOAWAY_SESSION\",\n  \"ERR_HTTP2_INVALID_SESSION\",\n  \"ERR_HTTP2_INVALID_STREAM\",\n  \"ERR_HTTP2_OUT_OF_STREAMS\",\n  \"ERR_HTTP2_SESSION_ERROR\",\n  \"ERR_HTTP2_STREAM_CANCEL\",\n  \"ERR_HTTP2_STREAM_ERROR\",\n];\n", "import type {\n  JSONValue,\n  QueryRequest,\n  QueryRequestHeaders,\n} from \"./wire-protocol\";\n\nexport interface QueryBuilder {\n  toQuery: (\n    headers?: QueryRequestHeaders,\n    intialArgNumber?: number\n  ) => QueryRequest;\n}\n\n/**\n * Creates a new QueryBuilder. Accepts template literal inputs.\n * @param queryFragments - a {@link TemplateStringsArray} that constitute\n *   the strings that are the basis of the query.\n * @param queryArgs - an Array\\<JSONValue | QueryBuilder\\> that\n *   constitute the arguments to inject between the queryFragments.\n * @throws Error - if you call this method directly (not using template\n *   literals) and pass invalid construction parameters\n * @example\n * ```typescript\n *  const str = \"baz\";\n *  const num = 17;\n *  const innerQueryBuilder = fql`Math.add(${num}, 3)`;\n *  const queryRequestBuilder = fql`${str}.length == ${innerQueryBuilder}`;\n * ```\n */\nexport function fql(\n  queryFragments: TemplateStringsArray,\n  ...queryArgs: (JSONValue | QueryBuilder)[]\n): QueryBuilder {\n  return QueryBuilderImpl.create(queryFragments, ...queryArgs);\n}\n\n/**\n * Internal class.\n * A builder for composing queries and QueryRequests.\n */\nclass QueryBuilderImpl implements QueryBuilder {\n  readonly #queryInterpolation: QueryInterpolation;\n\n  private constructor(queryInterpolation: QueryInterpolation) {\n    if (\"queryFragments\" in queryInterpolation) {\n      if (\n        queryInterpolation.queryFragments.length === 0 ||\n        queryInterpolation.queryFragments.length !==\n          queryInterpolation.queryArgs.length + 1\n      ) {\n        throw new Error(\"invalid query constructed\");\n      }\n      this.#queryInterpolation = {\n        ...queryInterpolation,\n        queryArgs: QueryBuilderImpl.#buildersFromArgs(\n          queryInterpolation.queryArgs\n        ),\n      };\n    } else {\n      this.#queryInterpolation = queryInterpolation;\n    }\n  }\n\n  /**\n   * Creates a new QueryBuilderImpl. Accepts template literal inputs.\n   * @param queryFragments - a {@link TemplateStringsArray} that constitute\n   *   the strings that are the basis of the query.\n   * @param queryArgs - an Array\\<JSONValue | QueryBuilderImpl\\> that\n   *   constitute the arguments to inject between the queryFragments.\n   * @throws Error - if you call this method directly (not using template\n   *   literals) and pass invalid construction parameters\n   * @example\n   * ```typescript\n   *  const str = \"baz\";\n   *  const num = 17;\n   *  const innerQueryBuilderImpl = QueryBuilderImpl.create`Math.add(${num}, 3)`;\n   *  const queryRequestBuilder = QueryBuilderImpl.create`${str}.length == ${innerQueryBuilderImpl}`;\n   * ```\n   */\n  static create(\n    queryFragments: TemplateStringsArray,\n    ...queryArgs: (JSONValue | QueryBuilder)[]\n  ) {\n    return new QueryBuilderImpl({\n      queryFragments,\n      queryArgs: QueryBuilderImpl.#buildersFromArgs(queryArgs),\n    });\n  }\n\n  /**\n   * Converts this QueryBuilderImpl to a {@link QueryRequest} you can send\n   * to Fauna.\n   * @param requestHeaders - optional {@link QueryRequestHeaders} to include\n   *   in the request (and thus override the defaults in your {@link ClientConfiguration}.\n   *   If not passed in, no headers will be set as overrides.\n   * @param initialArgNumber - optional number to start the argument names\n   *   with. Defaults to zero.\n   * @returns a {@link QueryRequest}.\n   * @example\n   * ```typescript\n   *  const str = \"baz\";\n   *  const num = 17;\n   *  const innerQueryBuilder = fql`Math.add(${num}, 3)`;\n   *  const queryRequestBuilder = fql`${str}.length == ${innerQueryBuilder}`;\n   *  const queryRequest: QueryRequest = queryRequestBuilder.toQuery();\n   *  // produces:\n   *  { query: \"arg0.length == Math.add(arg1, 3)\", arguments: { arg0: \"baz\", arg1: 17 }}\n   * ```\n   */\n  toQuery(\n    requestHeaders: QueryRequestHeaders = {},\n    initialArgNumber = 0\n  ): QueryRequest {\n    return { ...this.#render(initialArgNumber), ...requestHeaders };\n  }\n\n  static #buildersFromArgs(\n    queryArgs: (JSONValue | QueryBuilder)[]\n  ): QueryBuilder[] {\n    return queryArgs.map((queryArg) => {\n      if (typeof (<QueryBuilder>queryArg)?.toQuery === \"function\") {\n        return <QueryBuilder>queryArg;\n      }\n      return new QueryBuilderImpl({ json: <JSONValue>queryArg });\n    });\n  }\n\n  #render(nextArg = 0) {\n    if (\"queryFragments\" in this.#queryInterpolation) {\n      const { queryFragments, queryArgs: localArgs } = this.#queryInterpolation;\n      const queryFragment = queryFragments[0];\n      if (queryFragment === undefined) {\n        throw new Error(\"Internal error!\");\n      }\n      const renderedQuery: string[] = [queryFragment];\n      let args: Record<string, JSONValue> = {};\n      localArgs.forEach((arg, i) => {\n        const { query: argQuery, arguments: argArguments } = arg.toQuery(\n          {},\n          nextArg\n        );\n        if (argArguments !== undefined) {\n          nextArg += Object.keys(argArguments).length;\n        }\n        const queryFragment = queryFragments[i + 1];\n        if (queryFragment === undefined) {\n          throw new Error(\"Internal error!\");\n        }\n        renderedQuery.push(argQuery, queryFragment);\n        args = { ...args, ...argArguments };\n      });\n      return { query: renderedQuery.join(\"\"), arguments: args };\n    } else {\n      const argName = `arg${nextArg}`;\n      const args: { [x: string]: any } = {};\n      args[argName] = this.#queryInterpolation.json;\n      return {\n        query: `${argName}`,\n        arguments: args,\n      };\n    }\n  }\n}\n\n/**\n * A query that can be interpolated.\n * It can be composed of either a set of queryFragments and\n * queryArgs or a plain JSONValue.\n * Note that queryFragments and queryArgs are a javascript\n * artifact that support {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals | template literals}.\n */\ntype QueryInterpolation =\n  | {\n      queryFragments: TemplateStringsArray;\n      queryArgs: QueryBuilder[];\n    }\n  | {\n      json: JSONValue;\n    };\n"],
  "mappings": "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",
  "names": ["endpoints", "DefaultFetch", "resource", "options", "response", "status", "body", "queryResponseIsFailure", "res", "ServiceError", "httpStatus", "failure", "QueryRuntimeError", "QueryCheckError", "QueryTimeoutError", "AuthenticationError", "AuthorizationError", "ThrottlingError", "ServiceInternalError", "ServiceTimeoutError", "ClientError", "message", "options", "NetworkError", "ProtocolError", "error", "defaultClientConfiguration", "endpoints", "DefaultFetch", "_lastTxn", "_getSecret", "getSecret_fn", "_query", "query_fn", "_getError", "getError_fn", "_getServiceError", "getServiceError_fn", "_setHeaders", "setHeaders_fn", "Client", "clientConfiguration", "__privateAdd", "__privateMethod", "request", "headers", "partialClientConfig", "fallback", "maybeSecret", "queryRequest", "query", "args", "url", "response", "queryResult", "queryResponseIsFailure", "txn_time", "txnDate", "__privateGet", "__privateSet", "e", "ServiceError", "error", "ProtocolError", "nodeOrAxiosNetworkErrorCodes", "NetworkError", "ClientError", "httpStatus", "failure", "AuthenticationError", "AuthorizationError", "ServiceInternalError", "ServiceTimeoutError", "ThrottlingError", "QueryTimeoutError", "queryCheckFailureCodes", "QueryCheckError", "QueryRuntimeError", "fromObject", "headerObject", "entry", "headerValue", "headerKey", "tag", "fql", "queryFragments", "queryArgs", "QueryBuilderImpl", "_queryInterpolation", "_buildersFromArgs", "buildersFromArgs_fn", "_render", "render_fn", "_QueryBuilderImpl", "queryInterpolation", "__privateAdd", "_a", "__privateSet", "__privateMethod", "requestHeaders", "initialArgNumber", "queryArg", "nextArg", "__privateGet", "localArgs", "queryFragment", "renderedQuery", "args", "arg", "i", "argQuery", "argArguments", "argName"]
}
